// @generated by protobuf-ts 2.9.1 with parameter long_type_string,client_grpc1,generate_dependencies
// @generated from protobuf file "google/api/expr/v1alpha1/syntax.proto" (package "google.api.expr.v1alpha1", syntax proto3)
// tslint:disable
//
// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../protobuf/timestamp";
import { Duration } from "../../../protobuf/duration";
import { NullValue } from "../../../protobuf/struct";
// A representation of the abstract syntax of the Common Expression Language.

/**
 * An expression together with source information as returned by the parser.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.ParsedExpr
 */
export interface ParsedExpr {
    /**
     * The parsed expression.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr expr = 2;
     */
    expr?: Expr;
    /**
     * The source info derived from input that generated the parsed `expr`.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.SourceInfo source_info = 3;
     */
    sourceInfo?: SourceInfo;
}
/**
 * An abstract representation of a common expression.
 *
 * Expressions are abstractly represented as a collection of identifiers,
 * select statements, function calls, literals, and comprehensions. All
 * operators with the exception of the '.' operator are modelled as function
 * calls. This makes it easy to represent new operators into the existing AST.
 *
 * All references within expressions must resolve to a
 * [Decl][google.api.expr.v1alpha1.Decl] provided at type-check for an
 * expression to be valid. A reference may either be a bare identifier `name` or
 * a qualified identifier `google.api.name`. References may either refer to a
 * value or a function declaration.
 *
 * For example, the expression `google.api.name.startsWith('expr')` references
 * the declaration `google.api.name` within a
 * [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and the
 * function declaration `startsWith`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr
 */
export interface Expr {
    /**
     * Required. An id assigned to this node by the parser which is unique in a
     * given expression tree. This is used to associate type information and other
     * attributes to a node in the parse tree.
     *
     * @generated from protobuf field: int64 id = 2;
     */
    id: string;
    /**
     * @generated from protobuf oneof: expr_kind
     */
    exprKind: {
        oneofKind: "constExpr";
        /**
         * A literal expression.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Constant const_expr = 3;
         */
        constExpr: Constant;
    } | {
        oneofKind: "identExpr";
        /**
         * An identifier expression.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.Ident ident_expr = 4;
         */
        identExpr: Expr_Ident;
    } | {
        oneofKind: "selectExpr";
        /**
         * A field selection expression, e.g. `request.auth`.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.Select select_expr = 5;
         */
        selectExpr: Expr_Select;
    } | {
        oneofKind: "callExpr";
        /**
         * A call expression, including calls to predefined functions and operators.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.Call call_expr = 6;
         */
        callExpr: Expr_Call;
    } | {
        oneofKind: "listExpr";
        /**
         * A list creation expression.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.CreateList list_expr = 7;
         */
        listExpr: Expr_CreateList;
    } | {
        oneofKind: "structExpr";
        /**
         * A map or message creation expression.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.CreateStruct struct_expr = 8;
         */
        structExpr: Expr_CreateStruct;
    } | {
        oneofKind: "comprehensionExpr";
        /**
         * A comprehension expression.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.Comprehension comprehension_expr = 9;
         */
        comprehensionExpr: Expr_Comprehension;
    } | {
        oneofKind: undefined;
    };
}
/**
 * An identifier expression. e.g. `request`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.Ident
 */
export interface Expr_Ident {
    /**
     * Required. Holds a single, unqualified identifier, possibly preceded by a
     * '.'.
     *
     * Qualified names are represented by the
     * [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * A field selection expression. e.g. `request.auth`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.Select
 */
export interface Expr_Select {
    /**
     * Required. The target of the selection expression.
     *
     * For example, in the select expression `request.auth`, the `request`
     * portion of the expression is the `operand`.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr operand = 1;
     */
    operand?: Expr;
    /**
     * Required. The name of the field to select.
     *
     * For example, in the select expression `request.auth`, the `auth` portion
     * of the expression would be the `field`.
     *
     * @generated from protobuf field: string field = 2;
     */
    field: string;
    /**
     * Whether the select is to be interpreted as a field presence test.
     *
     * This results from the macro `has(request.auth)`.
     *
     * @generated from protobuf field: bool test_only = 3;
     */
    testOnly: boolean;
}
/**
 * A call expression, including calls to predefined functions and operators.
 *
 * For example, `value == 10`, `size(map_value)`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.Call
 */
export interface Expr_Call {
    /**
     * The target of an method call-style expression. For example, `x` in
     * `x.f()`.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr target = 1;
     */
    target?: Expr;
    /**
     * Required. The name of the function or method being called.
     *
     * @generated from protobuf field: string function = 2;
     */
    function: string;
    /**
     * The arguments.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.Expr args = 3;
     */
    args: Expr[];
}
/**
 * A list creation expression.
 *
 * Lists may either be homogenous, e.g. `[1, 2, 3]`, or heterogeneous, e.g.
 * `dyn([1, 'hello', 2.0])`
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.CreateList
 */
export interface Expr_CreateList {
    /**
     * The elements part of the list.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.Expr elements = 1;
     */
    elements: Expr[];
    /**
     * The indices within the elements list which are marked as optional
     * elements.
     *
     * When an optional-typed value is present, the value it contains
     * is included in the list. If the optional-typed value is absent, the list
     * element is omitted from the CreateList result.
     *
     * @generated from protobuf field: repeated int32 optional_indices = 2;
     */
    optionalIndices: number[];
}
/**
 * A map or message creation expression.
 *
 * Maps are constructed as `{'key_name': 'value'}`. Message construction is
 * similar, but prefixed with a type name and composed of field ids:
 * `types.MyType{field_id: 'value'}`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.CreateStruct
 */
export interface Expr_CreateStruct {
    /**
     * The type name of the message to be created, empty when creating map
     * literals.
     *
     * @generated from protobuf field: string message_name = 1;
     */
    messageName: string;
    /**
     * The entries in the creation expression.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.Expr.CreateStruct.Entry entries = 2;
     */
    entries: Expr_CreateStruct_Entry[];
}
/**
 * Represents an entry.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.CreateStruct.Entry
 */
export interface Expr_CreateStruct_Entry {
    /**
     * Required. An id assigned to this node by the parser which is unique
     * in a given expression tree. This is used to associate type
     * information and other attributes to the node.
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: string;
    /**
     * @generated from protobuf oneof: key_kind
     */
    keyKind: {
        oneofKind: "fieldKey";
        /**
         * The field key for a message creator statement.
         *
         * @generated from protobuf field: string field_key = 2;
         */
        fieldKey: string;
    } | {
        oneofKind: "mapKey";
        /**
         * The key expression for a map creation statement.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr map_key = 3;
         */
        mapKey: Expr;
    } | {
        oneofKind: undefined;
    };
    /**
     * Required. The value assigned to the key.
     *
     * If the optional_entry field is true, the expression must resolve to an
     * optional-typed value. If the optional value is present, the key will be
     * set; however, if the optional value is absent, the key will be unset.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr value = 4;
     */
    value?: Expr;
    /**
     * Whether the key-value pair is optional.
     *
     * @generated from protobuf field: bool optional_entry = 5;
     */
    optionalEntry: boolean;
}
/**
 * A comprehension expression applied to a list or map.
 *
 * Comprehensions are not part of the core syntax, but enabled with macros.
 * A macro matches a specific call signature within a parsed AST and replaces
 * the call with an alternate AST block. Macro expansion happens at parse
 * time.
 *
 * The following macros are supported within CEL:
 *
 * Aggregate type macros may be applied to all elements in a list or all keys
 * in a map:
 *
 * *  `all`, `exists`, `exists_one` -  test a predicate expression against
 *    the inputs and return `true` if the predicate is satisfied for all,
 *    any, or only one value `list.all(x, x < 10)`.
 * *  `filter` - test a predicate expression against the inputs and return
 *    the subset of elements which satisfy the predicate:
 *    `payments.filter(p, p > 1000)`.
 * *  `map` - apply an expression to all elements in the input and return the
 *    output aggregate type: `[1, 2, 3].map(i, i * i)`.
 *
 * The `has(m.x)` macro tests whether the property `x` is present in struct
 * `m`. The semantics of this macro depend on the type of `m`. For proto2
 * messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the
 * macro tests whether the property is set to its default. For map and struct
 * types, the macro tests whether the property `x` is defined on `m`.
 *
 * Comprehensions for the standard environment macros evaluation can be best
 * visualized as the following pseudocode:
 *
 * ```
 * let `accu_var` = `accu_init`
 * for (let `iter_var` in `iter_range`) {
 *   if (!`loop_condition`) {
 *     break
 *   }
 *   `accu_var` = `loop_step`
 * }
 * return `result`
 * ```
 *
 * Comprehensions for the optional V2 macros which support map-to-map
 * translation differ slightly from the standard environment macros in that
 * they expose both the key or index in addition to the value for each list
 * or map entry:
 *
 * ```
 * let `accu_var` = `accu_init`
 * for (let `iter_var`, `iter_var2` in `iter_range`) {
 *   if (!`loop_condition`) {
 *     break
 *   }
 *   `accu_var` = `loop_step`
 * }
 * return `result`
 * ```
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.Comprehension
 */
export interface Expr_Comprehension {
    /**
     * The name of the first iteration variable.
     * When the iter_range is a list, this variable is the list element.
     * When the iter_range is a map, this variable is the map entry key.
     *
     * @generated from protobuf field: string iter_var = 1;
     */
    iterVar: string;
    /**
     * The name of the second iteration variable, empty if not set.
     * When the iter_range is a list, this variable is the integer index.
     * When the iter_range is a map, this variable is the map entry value.
     * This field is only set for comprehension v2 macros.
     *
     * @generated from protobuf field: string iter_var2 = 8;
     */
    iterVar2: string;
    /**
     * The range over which the comprehension iterates.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr iter_range = 2;
     */
    iterRange?: Expr;
    /**
     * The name of the variable used for accumulation of the result.
     *
     * @generated from protobuf field: string accu_var = 3;
     */
    accuVar: string;
    /**
     * The initial value of the accumulator.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr accu_init = 4;
     */
    accuInit?: Expr;
    /**
     * An expression which can contain iter_var, iter_var2, and accu_var.
     *
     * Returns false when the result has been computed and may be used as
     * a hint to short-circuit the remainder of the comprehension.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr loop_condition = 5;
     */
    loopCondition?: Expr;
    /**
     * An expression which can contain iter_var, iter_var2, and accu_var.
     *
     * Computes the next value of accu_var.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr loop_step = 6;
     */
    loopStep?: Expr;
    /**
     * An expression which can contain accu_var.
     *
     * Computes the result.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr result = 7;
     */
    result?: Expr;
}
/**
 * Represents a primitive literal.
 *
 * Named 'Constant' here for backwards compatibility.
 *
 * This is similar as the primitives supported in the well-known type
 * `google.protobuf.Value`, but richer so it can represent CEL's full range of
 * primitives.
 *
 * Lists and structs are not included as constants as these aggregate types may
 * contain [Expr][google.api.expr.v1alpha1.Expr] elements which require
 * evaluation and are thus not constant.
 *
 * Examples of literals include: `"hello"`, `b'bytes'`, `1u`, `4.2`, `-2`,
 * `true`, `null`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Constant
 */
export interface Constant {
    /**
     * @generated from protobuf oneof: constant_kind
     */
    constantKind: {
        oneofKind: "nullValue";
        /**
         * null value.
         *
         * @generated from protobuf field: google.protobuf.NullValue null_value = 1;
         */
        nullValue: NullValue;
    } | {
        oneofKind: "boolValue";
        /**
         * boolean value.
         *
         * @generated from protobuf field: bool bool_value = 2;
         */
        boolValue: boolean;
    } | {
        oneofKind: "int64Value";
        /**
         * int64 value.
         *
         * @generated from protobuf field: int64 int64_value = 3;
         */
        int64Value: string;
    } | {
        oneofKind: "uint64Value";
        /**
         * uint64 value.
         *
         * @generated from protobuf field: uint64 uint64_value = 4;
         */
        uint64Value: string;
    } | {
        oneofKind: "doubleValue";
        /**
         * double value.
         *
         * @generated from protobuf field: double double_value = 5;
         */
        doubleValue: number;
    } | {
        oneofKind: "stringValue";
        /**
         * string value.
         *
         * @generated from protobuf field: string string_value = 6;
         */
        stringValue: string;
    } | {
        oneofKind: "bytesValue";
        /**
         * bytes value.
         *
         * @generated from protobuf field: bytes bytes_value = 7;
         */
        bytesValue: Uint8Array;
    } | {
        oneofKind: "durationValue";
        /**
         * protobuf.Duration value.
         *
         * Deprecated: duration is no longer considered a builtin cel type.
         *
         * @deprecated
         * @generated from protobuf field: google.protobuf.Duration duration_value = 8 [deprecated = true];
         */
        durationValue: Duration;
    } | {
        oneofKind: "timestampValue";
        /**
         * protobuf.Timestamp value.
         *
         * Deprecated: timestamp is no longer considered a builtin cel type.
         *
         * @deprecated
         * @generated from protobuf field: google.protobuf.Timestamp timestamp_value = 9 [deprecated = true];
         */
        timestampValue: Timestamp;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Source information collected at parse time.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.SourceInfo
 */
export interface SourceInfo {
    /**
     * The syntax version of the source, e.g. `cel1`.
     *
     * @generated from protobuf field: string syntax_version = 1;
     */
    syntaxVersion: string;
    /**
     * The location name. All position information attached to an expression is
     * relative to this location.
     *
     * The location could be a file, UI element, or similar. For example,
     * `acme/app/AnvilPolicy.cel`.
     *
     * @generated from protobuf field: string location = 2;
     */
    location: string;
    /**
     * Monotonically increasing list of code point offsets where newlines
     * `\n` appear.
     *
     * The line number of a given position is the index `i` where for a given
     * `id` the `line_offsets[i] < id_positions[id] < line_offsets[i+1]`. The
     * column may be derivd from `id_positions[id] - line_offsets[i]`.
     *
     * @generated from protobuf field: repeated int32 line_offsets = 3;
     */
    lineOffsets: number[];
    /**
     * A map from the parse node id (e.g. `Expr.id`) to the code point offset
     * within the source.
     *
     * @generated from protobuf field: map<int64, int32> positions = 4;
     */
    positions: {
        [key: string]: number;
    };
    /**
     * A map from the parse node id where a macro replacement was made to the
     * call `Expr` that resulted in a macro expansion.
     *
     * For example, `has(value.field)` is a function call that is replaced by a
     * `test_only` field selection in the AST. Likewise, the call
     * `list.exists(e, e > 10)` translates to a comprehension expression. The key
     * in the map corresponds to the expression id of the expanded macro, and the
     * value is the call `Expr` that was replaced.
     *
     * @generated from protobuf field: map<int64, google.api.expr.v1alpha1.Expr> macro_calls = 5;
     */
    macroCalls: {
        [key: string]: Expr;
    };
    /**
     * A list of tags for extensions that were used while parsing or type checking
     * the source expression. For example, optimizations that require special
     * runtime support may be specified.
     *
     * These are used to check feature support between components in separate
     * implementations. This can be used to either skip redundant work or
     * report an error if the extension is unsupported.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6;
     */
    extensions: SourceInfo_Extension[];
}
/**
 * An extension that was requested for the source expression.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.SourceInfo.Extension
 */
export interface SourceInfo_Extension {
    /**
     * Identifier for the extension. Example: constant_folding
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * If set, the listed components must understand the extension for the
     * expression to evaluate correctly.
     *
     * This field has set semantics, repeated values should be deduplicated.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2;
     */
    affectedComponents: SourceInfo_Extension_Component[];
    /**
     * Version info. May be skipped if it isn't meaningful for the extension.
     * (for example constant_folding might always be v0.0).
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3;
     */
    version?: SourceInfo_Extension_Version;
}
/**
 * Version
 *
 * @generated from protobuf message google.api.expr.v1alpha1.SourceInfo.Extension.Version
 */
export interface SourceInfo_Extension_Version {
    /**
     * Major version changes indicate different required support level from
     * the required components.
     *
     * @generated from protobuf field: int64 major = 1;
     */
    major: string;
    /**
     * Minor version changes must not change the observed behavior from
     * existing implementations, but may be provided informationally.
     *
     * @generated from protobuf field: int64 minor = 2;
     */
    minor: string;
}
/**
 * CEL component specifier.
 *
 * @generated from protobuf enum google.api.expr.v1alpha1.SourceInfo.Extension.Component
 */
export enum SourceInfo_Extension_Component {
    /**
     * Unspecified, default.
     *
     * @generated from protobuf enum value: COMPONENT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Parser. Converts a CEL string to an AST.
     *
     * @generated from protobuf enum value: COMPONENT_PARSER = 1;
     */
    PARSER = 1,
    /**
     * Type checker. Checks that references in an AST are defined and types
     * agree.
     *
     * @generated from protobuf enum value: COMPONENT_TYPE_CHECKER = 2;
     */
    TYPE_CHECKER = 2,
    /**
     * Runtime. Evaluates a parsed and optionally checked CEL AST against a
     * context.
     *
     * @generated from protobuf enum value: COMPONENT_RUNTIME = 3;
     */
    RUNTIME = 3
}
/**
 * A specific position in source.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.SourcePosition
 */
export interface SourcePosition {
    /**
     * The soucre location name (e.g. file name).
     *
     * @generated from protobuf field: string location = 1;
     */
    location: string;
    /**
     * The UTF-8 code unit offset.
     *
     * @generated from protobuf field: int32 offset = 2;
     */
    offset: number;
    /**
     * The 1-based index of the starting line in the source text
     * where the issue occurs, or 0 if unknown.
     *
     * @generated from protobuf field: int32 line = 3;
     */
    line: number;
    /**
     * The 0-based index of the starting position within the line of source text
     * where the issue occurs.  Only meaningful if line is nonzero.
     *
     * @generated from protobuf field: int32 column = 4;
     */
    column: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class ParsedExpr$Type extends MessageType<ParsedExpr> {
    constructor() {
        super("google.api.expr.v1alpha1.ParsedExpr", [
            { no: 2, name: "expr", kind: "message", T: () => Expr },
            { no: 3, name: "source_info", kind: "message", T: () => SourceInfo }
        ]);
    }
    create(value?: PartialMessage<ParsedExpr>): ParsedExpr {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ParsedExpr>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParsedExpr): ParsedExpr {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.api.expr.v1alpha1.Expr expr */ 2:
                    message.expr = Expr.internalBinaryRead(reader, reader.uint32(), options, message.expr);
                    break;
                case /* google.api.expr.v1alpha1.SourceInfo source_info */ 3:
                    message.sourceInfo = SourceInfo.internalBinaryRead(reader, reader.uint32(), options, message.sourceInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ParsedExpr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.api.expr.v1alpha1.Expr expr = 2; */
        if (message.expr)
            Expr.internalBinaryWrite(message.expr, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.SourceInfo source_info = 3; */
        if (message.sourceInfo)
            SourceInfo.internalBinaryWrite(message.sourceInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.ParsedExpr
 */
export const ParsedExpr = new ParsedExpr$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expr$Type extends MessageType<Expr> {
    constructor() {
        super("google.api.expr.v1alpha1.Expr", [
            { no: 2, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "const_expr", kind: "message", oneof: "exprKind", T: () => Constant },
            { no: 4, name: "ident_expr", kind: "message", oneof: "exprKind", T: () => Expr_Ident },
            { no: 5, name: "select_expr", kind: "message", oneof: "exprKind", T: () => Expr_Select },
            { no: 6, name: "call_expr", kind: "message", oneof: "exprKind", T: () => Expr_Call },
            { no: 7, name: "list_expr", kind: "message", oneof: "exprKind", T: () => Expr_CreateList },
            { no: 8, name: "struct_expr", kind: "message", oneof: "exprKind", T: () => Expr_CreateStruct },
            { no: 9, name: "comprehension_expr", kind: "message", oneof: "exprKind", T: () => Expr_Comprehension }
        ]);
    }
    create(value?: PartialMessage<Expr>): Expr {
        const message = { id: "0", exprKind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expr>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr): Expr {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 2:
                    message.id = reader.int64().toString();
                    break;
                case /* google.api.expr.v1alpha1.Constant const_expr */ 3:
                    message.exprKind = {
                        oneofKind: "constExpr",
                        constExpr: Constant.internalBinaryRead(reader, reader.uint32(), options, (message.exprKind as any).constExpr)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Expr.Ident ident_expr */ 4:
                    message.exprKind = {
                        oneofKind: "identExpr",
                        identExpr: Expr_Ident.internalBinaryRead(reader, reader.uint32(), options, (message.exprKind as any).identExpr)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Expr.Select select_expr */ 5:
                    message.exprKind = {
                        oneofKind: "selectExpr",
                        selectExpr: Expr_Select.internalBinaryRead(reader, reader.uint32(), options, (message.exprKind as any).selectExpr)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Expr.Call call_expr */ 6:
                    message.exprKind = {
                        oneofKind: "callExpr",
                        callExpr: Expr_Call.internalBinaryRead(reader, reader.uint32(), options, (message.exprKind as any).callExpr)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Expr.CreateList list_expr */ 7:
                    message.exprKind = {
                        oneofKind: "listExpr",
                        listExpr: Expr_CreateList.internalBinaryRead(reader, reader.uint32(), options, (message.exprKind as any).listExpr)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Expr.CreateStruct struct_expr */ 8:
                    message.exprKind = {
                        oneofKind: "structExpr",
                        structExpr: Expr_CreateStruct.internalBinaryRead(reader, reader.uint32(), options, (message.exprKind as any).structExpr)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Expr.Comprehension comprehension_expr */ 9:
                    message.exprKind = {
                        oneofKind: "comprehensionExpr",
                        comprehensionExpr: Expr_Comprehension.internalBinaryRead(reader, reader.uint32(), options, (message.exprKind as any).comprehensionExpr)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 2; */
        if (message.id !== "0")
            writer.tag(2, WireType.Varint).int64(message.id);
        /* google.api.expr.v1alpha1.Constant const_expr = 3; */
        if (message.exprKind.oneofKind === "constExpr")
            Constant.internalBinaryWrite(message.exprKind.constExpr, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr.Ident ident_expr = 4; */
        if (message.exprKind.oneofKind === "identExpr")
            Expr_Ident.internalBinaryWrite(message.exprKind.identExpr, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr.Select select_expr = 5; */
        if (message.exprKind.oneofKind === "selectExpr")
            Expr_Select.internalBinaryWrite(message.exprKind.selectExpr, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr.Call call_expr = 6; */
        if (message.exprKind.oneofKind === "callExpr")
            Expr_Call.internalBinaryWrite(message.exprKind.callExpr, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr.CreateList list_expr = 7; */
        if (message.exprKind.oneofKind === "listExpr")
            Expr_CreateList.internalBinaryWrite(message.exprKind.listExpr, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr.CreateStruct struct_expr = 8; */
        if (message.exprKind.oneofKind === "structExpr")
            Expr_CreateStruct.internalBinaryWrite(message.exprKind.structExpr, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr.Comprehension comprehension_expr = 9; */
        if (message.exprKind.oneofKind === "comprehensionExpr")
            Expr_Comprehension.internalBinaryWrite(message.exprKind.comprehensionExpr, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr
 */
export const Expr = new Expr$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expr_Ident$Type extends MessageType<Expr_Ident> {
    constructor() {
        super("google.api.expr.v1alpha1.Expr.Ident", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Expr_Ident>): Expr_Ident {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expr_Ident>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_Ident): Expr_Ident {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expr_Ident, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.Ident
 */
export const Expr_Ident = new Expr_Ident$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expr_Select$Type extends MessageType<Expr_Select> {
    constructor() {
        super("google.api.expr.v1alpha1.Expr.Select", [
            { no: 1, name: "operand", kind: "message", T: () => Expr },
            { no: 2, name: "field", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "test_only", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Expr_Select>): Expr_Select {
        const message = { field: "", testOnly: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expr_Select>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_Select): Expr_Select {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.api.expr.v1alpha1.Expr operand */ 1:
                    message.operand = Expr.internalBinaryRead(reader, reader.uint32(), options, message.operand);
                    break;
                case /* string field */ 2:
                    message.field = reader.string();
                    break;
                case /* bool test_only */ 3:
                    message.testOnly = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expr_Select, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.api.expr.v1alpha1.Expr operand = 1; */
        if (message.operand)
            Expr.internalBinaryWrite(message.operand, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string field = 2; */
        if (message.field !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.field);
        /* bool test_only = 3; */
        if (message.testOnly !== false)
            writer.tag(3, WireType.Varint).bool(message.testOnly);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.Select
 */
export const Expr_Select = new Expr_Select$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expr_Call$Type extends MessageType<Expr_Call> {
    constructor() {
        super("google.api.expr.v1alpha1.Expr.Call", [
            { no: 1, name: "target", kind: "message", T: () => Expr },
            { no: 2, name: "function", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "args", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expr }
        ]);
    }
    create(value?: PartialMessage<Expr_Call>): Expr_Call {
        const message = { function: "", args: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expr_Call>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_Call): Expr_Call {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.api.expr.v1alpha1.Expr target */ 1:
                    message.target = Expr.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                case /* string function */ 2:
                    message.function = reader.string();
                    break;
                case /* repeated google.api.expr.v1alpha1.Expr args */ 3:
                    message.args.push(Expr.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expr_Call, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.api.expr.v1alpha1.Expr target = 1; */
        if (message.target)
            Expr.internalBinaryWrite(message.target, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string function = 2; */
        if (message.function !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.function);
        /* repeated google.api.expr.v1alpha1.Expr args = 3; */
        for (let i = 0; i < message.args.length; i++)
            Expr.internalBinaryWrite(message.args[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.Call
 */
export const Expr_Call = new Expr_Call$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expr_CreateList$Type extends MessageType<Expr_CreateList> {
    constructor() {
        super("google.api.expr.v1alpha1.Expr.CreateList", [
            { no: 1, name: "elements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expr },
            { no: 2, name: "optional_indices", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Expr_CreateList>): Expr_CreateList {
        const message = { elements: [], optionalIndices: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expr_CreateList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_CreateList): Expr_CreateList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.api.expr.v1alpha1.Expr elements */ 1:
                    message.elements.push(Expr.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 optional_indices */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.optionalIndices.push(reader.int32());
                    else
                        message.optionalIndices.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expr_CreateList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.api.expr.v1alpha1.Expr elements = 1; */
        for (let i = 0; i < message.elements.length; i++)
            Expr.internalBinaryWrite(message.elements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 optional_indices = 2; */
        if (message.optionalIndices.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.optionalIndices.length; i++)
                writer.int32(message.optionalIndices[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.CreateList
 */
export const Expr_CreateList = new Expr_CreateList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expr_CreateStruct$Type extends MessageType<Expr_CreateStruct> {
    constructor() {
        super("google.api.expr.v1alpha1.Expr.CreateStruct", [
            { no: 1, name: "message_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "entries", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expr_CreateStruct_Entry }
        ]);
    }
    create(value?: PartialMessage<Expr_CreateStruct>): Expr_CreateStruct {
        const message = { messageName: "", entries: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expr_CreateStruct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_CreateStruct): Expr_CreateStruct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message_name */ 1:
                    message.messageName = reader.string();
                    break;
                case /* repeated google.api.expr.v1alpha1.Expr.CreateStruct.Entry entries */ 2:
                    message.entries.push(Expr_CreateStruct_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expr_CreateStruct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message_name = 1; */
        if (message.messageName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.messageName);
        /* repeated google.api.expr.v1alpha1.Expr.CreateStruct.Entry entries = 2; */
        for (let i = 0; i < message.entries.length; i++)
            Expr_CreateStruct_Entry.internalBinaryWrite(message.entries[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.CreateStruct
 */
export const Expr_CreateStruct = new Expr_CreateStruct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expr_CreateStruct_Entry$Type extends MessageType<Expr_CreateStruct_Entry> {
    constructor() {
        super("google.api.expr.v1alpha1.Expr.CreateStruct.Entry", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "field_key", kind: "scalar", oneof: "keyKind", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "map_key", kind: "message", oneof: "keyKind", T: () => Expr },
            { no: 4, name: "value", kind: "message", T: () => Expr },
            { no: 5, name: "optional_entry", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Expr_CreateStruct_Entry>): Expr_CreateStruct_Entry {
        const message = { id: "0", keyKind: { oneofKind: undefined }, optionalEntry: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expr_CreateStruct_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_CreateStruct_Entry): Expr_CreateStruct_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toString();
                    break;
                case /* string field_key */ 2:
                    message.keyKind = {
                        oneofKind: "fieldKey",
                        fieldKey: reader.string()
                    };
                    break;
                case /* google.api.expr.v1alpha1.Expr map_key */ 3:
                    message.keyKind = {
                        oneofKind: "mapKey",
                        mapKey: Expr.internalBinaryRead(reader, reader.uint32(), options, (message.keyKind as any).mapKey)
                    };
                    break;
                case /* google.api.expr.v1alpha1.Expr value */ 4:
                    message.value = Expr.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* bool optional_entry */ 5:
                    message.optionalEntry = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expr_CreateStruct_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== "0")
            writer.tag(1, WireType.Varint).int64(message.id);
        /* string field_key = 2; */
        if (message.keyKind.oneofKind === "fieldKey")
            writer.tag(2, WireType.LengthDelimited).string(message.keyKind.fieldKey);
        /* google.api.expr.v1alpha1.Expr map_key = 3; */
        if (message.keyKind.oneofKind === "mapKey")
            Expr.internalBinaryWrite(message.keyKind.mapKey, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr value = 4; */
        if (message.value)
            Expr.internalBinaryWrite(message.value, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool optional_entry = 5; */
        if (message.optionalEntry !== false)
            writer.tag(5, WireType.Varint).bool(message.optionalEntry);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.CreateStruct.Entry
 */
export const Expr_CreateStruct_Entry = new Expr_CreateStruct_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expr_Comprehension$Type extends MessageType<Expr_Comprehension> {
    constructor() {
        super("google.api.expr.v1alpha1.Expr.Comprehension", [
            { no: 1, name: "iter_var", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "iter_var2", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "iter_range", kind: "message", T: () => Expr },
            { no: 3, name: "accu_var", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "accu_init", kind: "message", T: () => Expr },
            { no: 5, name: "loop_condition", kind: "message", T: () => Expr },
            { no: 6, name: "loop_step", kind: "message", T: () => Expr },
            { no: 7, name: "result", kind: "message", T: () => Expr }
        ]);
    }
    create(value?: PartialMessage<Expr_Comprehension>): Expr_Comprehension {
        const message = { iterVar: "", iterVar2: "", accuVar: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expr_Comprehension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_Comprehension): Expr_Comprehension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string iter_var */ 1:
                    message.iterVar = reader.string();
                    break;
                case /* string iter_var2 */ 8:
                    message.iterVar2 = reader.string();
                    break;
                case /* google.api.expr.v1alpha1.Expr iter_range */ 2:
                    message.iterRange = Expr.internalBinaryRead(reader, reader.uint32(), options, message.iterRange);
                    break;
                case /* string accu_var */ 3:
                    message.accuVar = reader.string();
                    break;
                case /* google.api.expr.v1alpha1.Expr accu_init */ 4:
                    message.accuInit = Expr.internalBinaryRead(reader, reader.uint32(), options, message.accuInit);
                    break;
                case /* google.api.expr.v1alpha1.Expr loop_condition */ 5:
                    message.loopCondition = Expr.internalBinaryRead(reader, reader.uint32(), options, message.loopCondition);
                    break;
                case /* google.api.expr.v1alpha1.Expr loop_step */ 6:
                    message.loopStep = Expr.internalBinaryRead(reader, reader.uint32(), options, message.loopStep);
                    break;
                case /* google.api.expr.v1alpha1.Expr result */ 7:
                    message.result = Expr.internalBinaryRead(reader, reader.uint32(), options, message.result);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expr_Comprehension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string iter_var = 1; */
        if (message.iterVar !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.iterVar);
        /* string iter_var2 = 8; */
        if (message.iterVar2 !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.iterVar2);
        /* google.api.expr.v1alpha1.Expr iter_range = 2; */
        if (message.iterRange)
            Expr.internalBinaryWrite(message.iterRange, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string accu_var = 3; */
        if (message.accuVar !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accuVar);
        /* google.api.expr.v1alpha1.Expr accu_init = 4; */
        if (message.accuInit)
            Expr.internalBinaryWrite(message.accuInit, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr loop_condition = 5; */
        if (message.loopCondition)
            Expr.internalBinaryWrite(message.loopCondition, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr loop_step = 6; */
        if (message.loopStep)
            Expr.internalBinaryWrite(message.loopStep, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.api.expr.v1alpha1.Expr result = 7; */
        if (message.result)
            Expr.internalBinaryWrite(message.result, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.Comprehension
 */
export const Expr_Comprehension = new Expr_Comprehension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Constant$Type extends MessageType<Constant> {
    constructor() {
        super("google.api.expr.v1alpha1.Constant", [
            { no: 1, name: "null_value", kind: "enum", oneof: "constantKind", T: () => ["google.protobuf.NullValue", NullValue] },
            { no: 2, name: "bool_value", kind: "scalar", oneof: "constantKind", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "int64_value", kind: "scalar", oneof: "constantKind", T: 3 /*ScalarType.INT64*/ },
            { no: 4, name: "uint64_value", kind: "scalar", oneof: "constantKind", T: 4 /*ScalarType.UINT64*/ },
            { no: 5, name: "double_value", kind: "scalar", oneof: "constantKind", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "string_value", kind: "scalar", oneof: "constantKind", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "bytes_value", kind: "scalar", oneof: "constantKind", T: 12 /*ScalarType.BYTES*/ },
            { no: 8, name: "duration_value", kind: "message", oneof: "constantKind", T: () => Duration },
            { no: 9, name: "timestamp_value", kind: "message", oneof: "constantKind", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Constant>): Constant {
        const message = { constantKind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Constant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Constant): Constant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.NullValue null_value */ 1:
                    message.constantKind = {
                        oneofKind: "nullValue",
                        nullValue: reader.int32()
                    };
                    break;
                case /* bool bool_value */ 2:
                    message.constantKind = {
                        oneofKind: "boolValue",
                        boolValue: reader.bool()
                    };
                    break;
                case /* int64 int64_value */ 3:
                    message.constantKind = {
                        oneofKind: "int64Value",
                        int64Value: reader.int64().toString()
                    };
                    break;
                case /* uint64 uint64_value */ 4:
                    message.constantKind = {
                        oneofKind: "uint64Value",
                        uint64Value: reader.uint64().toString()
                    };
                    break;
                case /* double double_value */ 5:
                    message.constantKind = {
                        oneofKind: "doubleValue",
                        doubleValue: reader.double()
                    };
                    break;
                case /* string string_value */ 6:
                    message.constantKind = {
                        oneofKind: "stringValue",
                        stringValue: reader.string()
                    };
                    break;
                case /* bytes bytes_value */ 7:
                    message.constantKind = {
                        oneofKind: "bytesValue",
                        bytesValue: reader.bytes()
                    };
                    break;
                case /* google.protobuf.Duration duration_value = 8 [deprecated = true];*/ 8:
                    message.constantKind = {
                        oneofKind: "durationValue",
                        durationValue: Duration.internalBinaryRead(reader, reader.uint32(), options, (message.constantKind as any).durationValue)
                    };
                    break;
                case /* google.protobuf.Timestamp timestamp_value = 9 [deprecated = true];*/ 9:
                    message.constantKind = {
                        oneofKind: "timestampValue",
                        timestampValue: Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.constantKind as any).timestampValue)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Constant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.NullValue null_value = 1; */
        if (message.constantKind.oneofKind === "nullValue")
            writer.tag(1, WireType.Varint).int32(message.constantKind.nullValue);
        /* bool bool_value = 2; */
        if (message.constantKind.oneofKind === "boolValue")
            writer.tag(2, WireType.Varint).bool(message.constantKind.boolValue);
        /* int64 int64_value = 3; */
        if (message.constantKind.oneofKind === "int64Value")
            writer.tag(3, WireType.Varint).int64(message.constantKind.int64Value);
        /* uint64 uint64_value = 4; */
        if (message.constantKind.oneofKind === "uint64Value")
            writer.tag(4, WireType.Varint).uint64(message.constantKind.uint64Value);
        /* double double_value = 5; */
        if (message.constantKind.oneofKind === "doubleValue")
            writer.tag(5, WireType.Bit64).double(message.constantKind.doubleValue);
        /* string string_value = 6; */
        if (message.constantKind.oneofKind === "stringValue")
            writer.tag(6, WireType.LengthDelimited).string(message.constantKind.stringValue);
        /* bytes bytes_value = 7; */
        if (message.constantKind.oneofKind === "bytesValue")
            writer.tag(7, WireType.LengthDelimited).bytes(message.constantKind.bytesValue);
        /* google.protobuf.Duration duration_value = 8 [deprecated = true]; */
        if (message.constantKind.oneofKind === "durationValue")
            Duration.internalBinaryWrite(message.constantKind.durationValue, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp timestamp_value = 9 [deprecated = true]; */
        if (message.constantKind.oneofKind === "timestampValue")
            Timestamp.internalBinaryWrite(message.constantKind.timestampValue, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Constant
 */
export const Constant = new Constant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourceInfo$Type extends MessageType<SourceInfo> {
    constructor() {
        super("google.api.expr.v1alpha1.SourceInfo", [
            { no: 1, name: "syntax_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "location", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "line_offsets", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "positions", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 5, name: "macro_calls", kind: "map", K: 3 /*ScalarType.INT64*/, V: { kind: "message", T: () => Expr } },
            { no: 6, name: "extensions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SourceInfo_Extension }
        ]);
    }
    create(value?: PartialMessage<SourceInfo>): SourceInfo {
        const message = { syntaxVersion: "", location: "", lineOffsets: [], positions: {}, macroCalls: {}, extensions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SourceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceInfo): SourceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string syntax_version */ 1:
                    message.syntaxVersion = reader.string();
                    break;
                case /* string location */ 2:
                    message.location = reader.string();
                    break;
                case /* repeated int32 line_offsets */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.lineOffsets.push(reader.int32());
                    else
                        message.lineOffsets.push(reader.int32());
                    break;
                case /* map<int64, int32> positions */ 4:
                    this.binaryReadMap4(message.positions, reader, options);
                    break;
                case /* map<int64, google.api.expr.v1alpha1.Expr> macro_calls */ 5:
                    this.binaryReadMap5(message.macroCalls, reader, options);
                    break;
                case /* repeated google.api.expr.v1alpha1.SourceInfo.Extension extensions */ 6:
                    message.extensions.push(SourceInfo_Extension.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap4(map: SourceInfo["positions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SourceInfo["positions"] | undefined, val: SourceInfo["positions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.expr.v1alpha1.SourceInfo.positions");
            }
        }
        map[key ?? "0"] = val ?? 0;
    }
    private binaryReadMap5(map: SourceInfo["macroCalls"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SourceInfo["macroCalls"] | undefined, val: SourceInfo["macroCalls"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.int64().toString();
                    break;
                case 2:
                    val = Expr.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.api.expr.v1alpha1.SourceInfo.macro_calls");
            }
        }
        map[key ?? "0"] = val ?? Expr.create();
    }
    internalBinaryWrite(message: SourceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string syntax_version = 1; */
        if (message.syntaxVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.syntaxVersion);
        /* string location = 2; */
        if (message.location !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.location);
        /* repeated int32 line_offsets = 3; */
        if (message.lineOffsets.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.lineOffsets.length; i++)
                writer.int32(message.lineOffsets[i]);
            writer.join();
        }
        /* map<int64, int32> positions = 4; */
        for (let k of Object.keys(message.positions))
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k).tag(2, WireType.Varint).int32(message.positions[k]).join();
        /* map<int64, google.api.expr.v1alpha1.Expr> macro_calls = 5; */
        for (let k of Object.keys(message.macroCalls)) {
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.Varint).int64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Expr.internalBinaryWrite(message.macroCalls[k], writer, options);
            writer.join().join();
        }
        /* repeated google.api.expr.v1alpha1.SourceInfo.Extension extensions = 6; */
        for (let i = 0; i < message.extensions.length; i++)
            SourceInfo_Extension.internalBinaryWrite(message.extensions[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.SourceInfo
 */
export const SourceInfo = new SourceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourceInfo_Extension$Type extends MessageType<SourceInfo_Extension> {
    constructor() {
        super("google.api.expr.v1alpha1.SourceInfo.Extension", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "affected_components", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["google.api.expr.v1alpha1.SourceInfo.Extension.Component", SourceInfo_Extension_Component, "COMPONENT_"] },
            { no: 3, name: "version", kind: "message", T: () => SourceInfo_Extension_Version }
        ]);
    }
    create(value?: PartialMessage<SourceInfo_Extension>): SourceInfo_Extension {
        const message = { id: "", affectedComponents: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SourceInfo_Extension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceInfo_Extension): SourceInfo_Extension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.affectedComponents.push(reader.int32());
                    else
                        message.affectedComponents.push(reader.int32());
                    break;
                case /* google.api.expr.v1alpha1.SourceInfo.Extension.Version version */ 3:
                    message.version = SourceInfo_Extension_Version.internalBinaryRead(reader, reader.uint32(), options, message.version);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SourceInfo_Extension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated google.api.expr.v1alpha1.SourceInfo.Extension.Component affected_components = 2; */
        if (message.affectedComponents.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.affectedComponents.length; i++)
                writer.int32(message.affectedComponents[i]);
            writer.join();
        }
        /* google.api.expr.v1alpha1.SourceInfo.Extension.Version version = 3; */
        if (message.version)
            SourceInfo_Extension_Version.internalBinaryWrite(message.version, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.SourceInfo.Extension
 */
export const SourceInfo_Extension = new SourceInfo_Extension$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourceInfo_Extension_Version$Type extends MessageType<SourceInfo_Extension_Version> {
    constructor() {
        super("google.api.expr.v1alpha1.SourceInfo.Extension.Version", [
            { no: 1, name: "major", kind: "scalar", T: 3 /*ScalarType.INT64*/ },
            { no: 2, name: "minor", kind: "scalar", T: 3 /*ScalarType.INT64*/ }
        ]);
    }
    create(value?: PartialMessage<SourceInfo_Extension_Version>): SourceInfo_Extension_Version {
        const message = { major: "0", minor: "0" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SourceInfo_Extension_Version>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceInfo_Extension_Version): SourceInfo_Extension_Version {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 major */ 1:
                    message.major = reader.int64().toString();
                    break;
                case /* int64 minor */ 2:
                    message.minor = reader.int64().toString();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SourceInfo_Extension_Version, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 major = 1; */
        if (message.major !== "0")
            writer.tag(1, WireType.Varint).int64(message.major);
        /* int64 minor = 2; */
        if (message.minor !== "0")
            writer.tag(2, WireType.Varint).int64(message.minor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.SourceInfo.Extension.Version
 */
export const SourceInfo_Extension_Version = new SourceInfo_Extension_Version$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SourcePosition$Type extends MessageType<SourcePosition> {
    constructor() {
        super("google.api.expr.v1alpha1.SourcePosition", [
            { no: 1, name: "location", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "offset", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "line", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "column", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SourcePosition>): SourcePosition {
        const message = { location: "", offset: 0, line: 0, column: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SourcePosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourcePosition): SourcePosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string location */ 1:
                    message.location = reader.string();
                    break;
                case /* int32 offset */ 2:
                    message.offset = reader.int32();
                    break;
                case /* int32 line */ 3:
                    message.line = reader.int32();
                    break;
                case /* int32 column */ 4:
                    message.column = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SourcePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string location = 1; */
        if (message.location !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.location);
        /* int32 offset = 2; */
        if (message.offset !== 0)
            writer.tag(2, WireType.Varint).int32(message.offset);
        /* int32 line = 3; */
        if (message.line !== 0)
            writer.tag(3, WireType.Varint).int32(message.line);
        /* int32 column = 4; */
        if (message.column !== 0)
            writer.tag(4, WireType.Varint).int32(message.column);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.SourcePosition
 */
export const SourcePosition = new SourcePosition$Type();
