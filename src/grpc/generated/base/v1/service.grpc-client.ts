// @generated by protobuf-ts 2.9.1 with parameter long_type_string,client_grpc1,generate_dependencies
// @generated from protobuf file "base/v1/service.proto" (package "base.v1", syntax proto3)
// tslint:disable
import { Tenancy } from "./service";
import type { TenantListResponse } from "./service";
import type { TenantListRequest } from "./service";
import type { TenantDeleteResponse } from "./service";
import type { TenantDeleteRequest } from "./service";
import type { TenantCreateResponse } from "./service";
import type { TenantCreateRequest } from "./service";
import { Bundle } from "./service";
import type { BundleDeleteResponse } from "./service";
import type { BundleDeleteRequest } from "./service";
import type { BundleReadResponse } from "./service";
import type { BundleReadRequest } from "./service";
import type { BundleWriteResponse } from "./service";
import type { BundleWriteRequest } from "./service";
import { Data } from "./service";
import type { BundleRunResponse } from "./service";
import type { BundleRunRequest } from "./service";
import type { RelationshipDeleteResponse } from "./service";
import type { RelationshipDeleteRequest } from "./service";
import type { DataDeleteResponse } from "./service";
import type { DataDeleteRequest } from "./service";
import type { AttributeReadResponse } from "./service";
import type { AttributeReadRequest } from "./service";
import type { RelationshipReadResponse } from "./service";
import type { RelationshipReadRequest } from "./service";
import type { RelationshipWriteResponse } from "./service";
import type { RelationshipWriteRequest } from "./service";
import type { DataWriteResponse } from "./service";
import type { DataWriteRequest } from "./service";
import { Schema } from "./service";
import type { SchemaListResponse } from "./service";
import type { SchemaListRequest } from "./service";
import type { SchemaReadResponse } from "./service";
import type { SchemaReadRequest } from "./service";
import type { SchemaPartialWriteResponse } from "./service";
import type { SchemaPartialWriteRequest } from "./service";
import type { SchemaWriteResponse } from "./service";
import type { SchemaWriteRequest } from "./service";
import { Watch } from "./service";
import type { WatchResponse } from "./service";
import type { WatchRequest } from "./service";
import { Permission } from "./service";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { PermissionSubjectPermissionResponse } from "./service";
import type { PermissionSubjectPermissionRequest } from "./service";
import type { PermissionLookupSubjectResponse } from "./service";
import type { PermissionLookupSubjectRequest } from "./service";
import type { PermissionLookupEntityStreamResponse } from "./service";
import type { PermissionLookupEntityResponse } from "./service";
import type { PermissionLookupEntityRequest } from "./service";
import type { PermissionExpandResponse } from "./service";
import type { PermissionExpandRequest } from "./service";
import type { PermissionCheckResponse } from "./service";
import type { PermissionCheckRequest } from "./service";
import * as grpc from "@grpc/grpc-js";
/**
 * ** PERMISSION SERVICE **
 * Permission service contains methods to interact with permissions.
 *
 * @generated from protobuf service base.v1.Permission
 */
export interface IPermissionClient {
    /**
     * Check method receives a PermissionCheckRequest and returns a PermissionCheckResponse.
     * It is used to determine whether a specific user has permission to perform an action on a resource.
     * For example, "Can the user 1 push to repository 1?"
     *
     * @generated from protobuf rpc: Check(base.v1.PermissionCheckRequest) returns (base.v1.PermissionCheckResponse);
     */
    check(input: PermissionCheckRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PermissionCheckResponse) => void): grpc.ClientUnaryCall;
    check(input: PermissionCheckRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: PermissionCheckResponse) => void): grpc.ClientUnaryCall;
    check(input: PermissionCheckRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PermissionCheckResponse) => void): grpc.ClientUnaryCall;
    check(input: PermissionCheckRequest, callback: (err: grpc.ServiceError | null, value?: PermissionCheckResponse) => void): grpc.ClientUnaryCall;
    /**
     * Expand method receives a PermissionExpandRequest and returns a PermissionExpandResponse.
     * It expands relationships according to the schema provided.
     *
     * @generated from protobuf rpc: Expand(base.v1.PermissionExpandRequest) returns (base.v1.PermissionExpandResponse);
     */
    expand(input: PermissionExpandRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PermissionExpandResponse) => void): grpc.ClientUnaryCall;
    expand(input: PermissionExpandRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: PermissionExpandResponse) => void): grpc.ClientUnaryCall;
    expand(input: PermissionExpandRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PermissionExpandResponse) => void): grpc.ClientUnaryCall;
    expand(input: PermissionExpandRequest, callback: (err: grpc.ServiceError | null, value?: PermissionExpandResponse) => void): grpc.ClientUnaryCall;
    /**
     * LookupEntity method receives a PermissionLookupEntityRequest and returns a PermissionLookupEntityResponse.
     * It is used to retrieve an entity by its identifier.
     *
     * @generated from protobuf rpc: LookupEntity(base.v1.PermissionLookupEntityRequest) returns (base.v1.PermissionLookupEntityResponse);
     */
    lookupEntity(input: PermissionLookupEntityRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PermissionLookupEntityResponse) => void): grpc.ClientUnaryCall;
    lookupEntity(input: PermissionLookupEntityRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: PermissionLookupEntityResponse) => void): grpc.ClientUnaryCall;
    lookupEntity(input: PermissionLookupEntityRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PermissionLookupEntityResponse) => void): grpc.ClientUnaryCall;
    lookupEntity(input: PermissionLookupEntityRequest, callback: (err: grpc.ServiceError | null, value?: PermissionLookupEntityResponse) => void): grpc.ClientUnaryCall;
    /**
     * LookupEntityStream method receives a PermissionLookupEntityRequest and streams a series of PermissionLookupEntityStreamResponse messages.
     * It is used to retrieve entities by their identifiers in a streaming fashion.
     *
     * @generated from protobuf rpc: LookupEntityStream(base.v1.PermissionLookupEntityRequest) returns (stream base.v1.PermissionLookupEntityStreamResponse);
     */
    lookupEntityStream(input: PermissionLookupEntityRequest, metadata?: grpc.Metadata, options?: grpc.CallOptions): grpc.ClientReadableStream<PermissionLookupEntityStreamResponse>;
    lookupEntityStream(input: PermissionLookupEntityRequest, options?: grpc.CallOptions): grpc.ClientReadableStream<PermissionLookupEntityStreamResponse>;
    /**
     * LookupSubject method receives a PermissionLookupSubjectRequest and returns a PermissionLookupSubjectResponse.
     * It is used to retrieve a subject by its identifier.
     *
     * @generated from protobuf rpc: LookupSubject(base.v1.PermissionLookupSubjectRequest) returns (base.v1.PermissionLookupSubjectResponse);
     */
    lookupSubject(input: PermissionLookupSubjectRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PermissionLookupSubjectResponse) => void): grpc.ClientUnaryCall;
    lookupSubject(input: PermissionLookupSubjectRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: PermissionLookupSubjectResponse) => void): grpc.ClientUnaryCall;
    lookupSubject(input: PermissionLookupSubjectRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PermissionLookupSubjectResponse) => void): grpc.ClientUnaryCall;
    lookupSubject(input: PermissionLookupSubjectRequest, callback: (err: grpc.ServiceError | null, value?: PermissionLookupSubjectResponse) => void): grpc.ClientUnaryCall;
    /**
     * SubjectPermission method receives a PermissionSubjectPermissionRequest and returns a PermissionSubjectPermissionResponse.
     * It is used to retrieve permissions related to a specific subject.
     *
     * @generated from protobuf rpc: SubjectPermission(base.v1.PermissionSubjectPermissionRequest) returns (base.v1.PermissionSubjectPermissionResponse);
     */
    subjectPermission(input: PermissionSubjectPermissionRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PermissionSubjectPermissionResponse) => void): grpc.ClientUnaryCall;
    subjectPermission(input: PermissionSubjectPermissionRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: PermissionSubjectPermissionResponse) => void): grpc.ClientUnaryCall;
    subjectPermission(input: PermissionSubjectPermissionRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: PermissionSubjectPermissionResponse) => void): grpc.ClientUnaryCall;
    subjectPermission(input: PermissionSubjectPermissionRequest, callback: (err: grpc.ServiceError | null, value?: PermissionSubjectPermissionResponse) => void): grpc.ClientUnaryCall;
}
/**
 * ** PERMISSION SERVICE **
 * Permission service contains methods to interact with permissions.
 *
 * @generated from protobuf service base.v1.Permission
 */
export class PermissionClient extends grpc.Client implements IPermissionClient {
    private readonly _binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions>;
    constructor(address: string, credentials: grpc.ChannelCredentials, options: grpc.ClientOptions = {}, binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions> = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     * Check method receives a PermissionCheckRequest and returns a PermissionCheckResponse.
     * It is used to determine whether a specific user has permission to perform an action on a resource.
     * For example, "Can the user 1 push to repository 1?"
     *
     * @generated from protobuf rpc: Check(base.v1.PermissionCheckRequest) returns (base.v1.PermissionCheckResponse);
     */
    check(input: PermissionCheckRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PermissionCheckResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PermissionCheckResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: PermissionCheckResponse) => void)): grpc.ClientUnaryCall {
        const method = Permission.methods[0];
        return this.makeUnaryRequest<PermissionCheckRequest, PermissionCheckResponse>(`/${Permission.typeName}/${method.name}`, (value: PermissionCheckRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): PermissionCheckResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * Expand method receives a PermissionExpandRequest and returns a PermissionExpandResponse.
     * It expands relationships according to the schema provided.
     *
     * @generated from protobuf rpc: Expand(base.v1.PermissionExpandRequest) returns (base.v1.PermissionExpandResponse);
     */
    expand(input: PermissionExpandRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PermissionExpandResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PermissionExpandResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: PermissionExpandResponse) => void)): grpc.ClientUnaryCall {
        const method = Permission.methods[1];
        return this.makeUnaryRequest<PermissionExpandRequest, PermissionExpandResponse>(`/${Permission.typeName}/${method.name}`, (value: PermissionExpandRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): PermissionExpandResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * LookupEntity method receives a PermissionLookupEntityRequest and returns a PermissionLookupEntityResponse.
     * It is used to retrieve an entity by its identifier.
     *
     * @generated from protobuf rpc: LookupEntity(base.v1.PermissionLookupEntityRequest) returns (base.v1.PermissionLookupEntityResponse);
     */
    lookupEntity(input: PermissionLookupEntityRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PermissionLookupEntityResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PermissionLookupEntityResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: PermissionLookupEntityResponse) => void)): grpc.ClientUnaryCall {
        const method = Permission.methods[2];
        return this.makeUnaryRequest<PermissionLookupEntityRequest, PermissionLookupEntityResponse>(`/${Permission.typeName}/${method.name}`, (value: PermissionLookupEntityRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): PermissionLookupEntityResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * LookupEntityStream method receives a PermissionLookupEntityRequest and streams a series of PermissionLookupEntityStreamResponse messages.
     * It is used to retrieve entities by their identifiers in a streaming fashion.
     *
     * @generated from protobuf rpc: LookupEntityStream(base.v1.PermissionLookupEntityRequest) returns (stream base.v1.PermissionLookupEntityStreamResponse);
     */
    lookupEntityStream(input: PermissionLookupEntityRequest, metadata?: grpc.Metadata | grpc.CallOptions, options?: grpc.CallOptions): grpc.ClientReadableStream<PermissionLookupEntityStreamResponse> {
        const method = Permission.methods[3];
        return this.makeServerStreamRequest<PermissionLookupEntityRequest, PermissionLookupEntityStreamResponse>(`/${Permission.typeName}/${method.name}`, (value: PermissionLookupEntityRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): PermissionLookupEntityStreamResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), options);
    }
    /**
     * LookupSubject method receives a PermissionLookupSubjectRequest and returns a PermissionLookupSubjectResponse.
     * It is used to retrieve a subject by its identifier.
     *
     * @generated from protobuf rpc: LookupSubject(base.v1.PermissionLookupSubjectRequest) returns (base.v1.PermissionLookupSubjectResponse);
     */
    lookupSubject(input: PermissionLookupSubjectRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PermissionLookupSubjectResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PermissionLookupSubjectResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: PermissionLookupSubjectResponse) => void)): grpc.ClientUnaryCall {
        const method = Permission.methods[4];
        return this.makeUnaryRequest<PermissionLookupSubjectRequest, PermissionLookupSubjectResponse>(`/${Permission.typeName}/${method.name}`, (value: PermissionLookupSubjectRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): PermissionLookupSubjectResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * SubjectPermission method receives a PermissionSubjectPermissionRequest and returns a PermissionSubjectPermissionResponse.
     * It is used to retrieve permissions related to a specific subject.
     *
     * @generated from protobuf rpc: SubjectPermission(base.v1.PermissionSubjectPermissionRequest) returns (base.v1.PermissionSubjectPermissionResponse);
     */
    subjectPermission(input: PermissionSubjectPermissionRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PermissionSubjectPermissionResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: PermissionSubjectPermissionResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: PermissionSubjectPermissionResponse) => void)): grpc.ClientUnaryCall {
        const method = Permission.methods[5];
        return this.makeUnaryRequest<PermissionSubjectPermissionRequest, PermissionSubjectPermissionResponse>(`/${Permission.typeName}/${method.name}`, (value: PermissionSubjectPermissionRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): PermissionSubjectPermissionResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
}
// ** WATCH SERVICE **

// Watch service provides a streaming RPC that can be used to watch changes in the data.

/**
 * Watch is the main RPC in the Watch service. It establishes a stream between
 * the client and the server. The server pushes data changes into this stream
 * and the client can read those in real time.
 *
 * @generated from protobuf service base.v1.Watch
 */
export interface IWatchClient {
    /**
     * @generated from protobuf rpc: Watch(base.v1.WatchRequest) returns (stream base.v1.WatchResponse);
     */
    watch(input: WatchRequest, metadata?: grpc.Metadata, options?: grpc.CallOptions): grpc.ClientReadableStream<WatchResponse>;
    watch(input: WatchRequest, options?: grpc.CallOptions): grpc.ClientReadableStream<WatchResponse>;
}
// ** WATCH SERVICE **

// Watch service provides a streaming RPC that can be used to watch changes in the data.

/**
 * Watch is the main RPC in the Watch service. It establishes a stream between
 * the client and the server. The server pushes data changes into this stream
 * and the client can read those in real time.
 *
 * @generated from protobuf service base.v1.Watch
 */
export class WatchClient extends grpc.Client implements IWatchClient {
    private readonly _binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions>;
    constructor(address: string, credentials: grpc.ChannelCredentials, options: grpc.ClientOptions = {}, binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions> = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     * @generated from protobuf rpc: Watch(base.v1.WatchRequest) returns (stream base.v1.WatchResponse);
     */
    watch(input: WatchRequest, metadata?: grpc.Metadata | grpc.CallOptions, options?: grpc.CallOptions): grpc.ClientReadableStream<WatchResponse> {
        const method = Watch.methods[0];
        return this.makeServerStreamRequest<WatchRequest, WatchResponse>(`/${Watch.typeName}/${method.name}`, (value: WatchRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): WatchResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), options);
    }
}
// ** SCHEMA SERVICE **

// Schema service provides methods to manage the authorization model of your application.
// It allows you to read and write the schema of your authorization model.

/**
 * The Schema service definition.
 *
 * @generated from protobuf service base.v1.Schema
 */
export interface ISchemaClient {
    /**
     * Write is an RPC that allows you to write your authorization model.
     *
     * @generated from protobuf rpc: Write(base.v1.SchemaWriteRequest) returns (base.v1.SchemaWriteResponse);
     */
    write(input: SchemaWriteRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SchemaWriteResponse) => void): grpc.ClientUnaryCall;
    write(input: SchemaWriteRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: SchemaWriteResponse) => void): grpc.ClientUnaryCall;
    write(input: SchemaWriteRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SchemaWriteResponse) => void): grpc.ClientUnaryCall;
    write(input: SchemaWriteRequest, callback: (err: grpc.ServiceError | null, value?: SchemaWriteResponse) => void): grpc.ClientUnaryCall;
    /**
     * PartialWrite is an RPC that allows you to partially update an existing authorization model.
     *
     * @generated from protobuf rpc: PartialWrite(base.v1.SchemaPartialWriteRequest) returns (base.v1.SchemaPartialWriteResponse);
     */
    partialWrite(input: SchemaPartialWriteRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SchemaPartialWriteResponse) => void): grpc.ClientUnaryCall;
    partialWrite(input: SchemaPartialWriteRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: SchemaPartialWriteResponse) => void): grpc.ClientUnaryCall;
    partialWrite(input: SchemaPartialWriteRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SchemaPartialWriteResponse) => void): grpc.ClientUnaryCall;
    partialWrite(input: SchemaPartialWriteRequest, callback: (err: grpc.ServiceError | null, value?: SchemaPartialWriteResponse) => void): grpc.ClientUnaryCall;
    /**
     * Read is an RPC that allows you to read your authorization model.
     *
     * @generated from protobuf rpc: Read(base.v1.SchemaReadRequest) returns (base.v1.SchemaReadResponse);
     */
    read(input: SchemaReadRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SchemaReadResponse) => void): grpc.ClientUnaryCall;
    read(input: SchemaReadRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: SchemaReadResponse) => void): grpc.ClientUnaryCall;
    read(input: SchemaReadRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SchemaReadResponse) => void): grpc.ClientUnaryCall;
    read(input: SchemaReadRequest, callback: (err: grpc.ServiceError | null, value?: SchemaReadResponse) => void): grpc.ClientUnaryCall;
    /**
     * List is an RPC that allows you to list all authorization models.
     *
     * @generated from protobuf rpc: List(base.v1.SchemaListRequest) returns (base.v1.SchemaListResponse);
     */
    list(input: SchemaListRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SchemaListResponse) => void): grpc.ClientUnaryCall;
    list(input: SchemaListRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: SchemaListResponse) => void): grpc.ClientUnaryCall;
    list(input: SchemaListRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: SchemaListResponse) => void): grpc.ClientUnaryCall;
    list(input: SchemaListRequest, callback: (err: grpc.ServiceError | null, value?: SchemaListResponse) => void): grpc.ClientUnaryCall;
}
// ** SCHEMA SERVICE **

// Schema service provides methods to manage the authorization model of your application.
// It allows you to read and write the schema of your authorization model.

/**
 * The Schema service definition.
 *
 * @generated from protobuf service base.v1.Schema
 */
export class SchemaClient extends grpc.Client implements ISchemaClient {
    private readonly _binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions>;
    constructor(address: string, credentials: grpc.ChannelCredentials, options: grpc.ClientOptions = {}, binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions> = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     * Write is an RPC that allows you to write your authorization model.
     *
     * @generated from protobuf rpc: Write(base.v1.SchemaWriteRequest) returns (base.v1.SchemaWriteResponse);
     */
    write(input: SchemaWriteRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SchemaWriteResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SchemaWriteResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: SchemaWriteResponse) => void)): grpc.ClientUnaryCall {
        const method = Schema.methods[0];
        return this.makeUnaryRequest<SchemaWriteRequest, SchemaWriteResponse>(`/${Schema.typeName}/${method.name}`, (value: SchemaWriteRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): SchemaWriteResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * PartialWrite is an RPC that allows you to partially update an existing authorization model.
     *
     * @generated from protobuf rpc: PartialWrite(base.v1.SchemaPartialWriteRequest) returns (base.v1.SchemaPartialWriteResponse);
     */
    partialWrite(input: SchemaPartialWriteRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SchemaPartialWriteResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SchemaPartialWriteResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: SchemaPartialWriteResponse) => void)): grpc.ClientUnaryCall {
        const method = Schema.methods[1];
        return this.makeUnaryRequest<SchemaPartialWriteRequest, SchemaPartialWriteResponse>(`/${Schema.typeName}/${method.name}`, (value: SchemaPartialWriteRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): SchemaPartialWriteResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * Read is an RPC that allows you to read your authorization model.
     *
     * @generated from protobuf rpc: Read(base.v1.SchemaReadRequest) returns (base.v1.SchemaReadResponse);
     */
    read(input: SchemaReadRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SchemaReadResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SchemaReadResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: SchemaReadResponse) => void)): grpc.ClientUnaryCall {
        const method = Schema.methods[2];
        return this.makeUnaryRequest<SchemaReadRequest, SchemaReadResponse>(`/${Schema.typeName}/${method.name}`, (value: SchemaReadRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): SchemaReadResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * List is an RPC that allows you to list all authorization models.
     *
     * @generated from protobuf rpc: List(base.v1.SchemaListRequest) returns (base.v1.SchemaListResponse);
     */
    list(input: SchemaListRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SchemaListResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: SchemaListResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: SchemaListResponse) => void)): grpc.ClientUnaryCall {
        const method = Schema.methods[3];
        return this.makeUnaryRequest<SchemaListRequest, SchemaListResponse>(`/${Schema.typeName}/${method.name}`, (value: SchemaListRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): SchemaListResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
}
// ** DATA SERVICE **

/**
 * The Data service provides RPC methods for managing data in the context of relationships and attributes.
 *
 * @generated from protobuf service base.v1.Data
 */
export interface IDataClient {
    /**
     * The Write RPC method creates a new relation tuple.
     *
     * @generated from protobuf rpc: Write(base.v1.DataWriteRequest) returns (base.v1.DataWriteResponse);
     */
    write(input: DataWriteRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DataWriteResponse) => void): grpc.ClientUnaryCall;
    write(input: DataWriteRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: DataWriteResponse) => void): grpc.ClientUnaryCall;
    write(input: DataWriteRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DataWriteResponse) => void): grpc.ClientUnaryCall;
    write(input: DataWriteRequest, callback: (err: grpc.ServiceError | null, value?: DataWriteResponse) => void): grpc.ClientUnaryCall;
    /**
     * RPC method to write relationships for a tenant. This can be accessed via a POST request to the given HTTP path. It's tagged under "Data" in OpenAPI documentation.
     *
     * @generated from protobuf rpc: WriteRelationships(base.v1.RelationshipWriteRequest) returns (base.v1.RelationshipWriteResponse);
     */
    writeRelationships(input: RelationshipWriteRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: RelationshipWriteResponse) => void): grpc.ClientUnaryCall;
    writeRelationships(input: RelationshipWriteRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: RelationshipWriteResponse) => void): grpc.ClientUnaryCall;
    writeRelationships(input: RelationshipWriteRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: RelationshipWriteResponse) => void): grpc.ClientUnaryCall;
    writeRelationships(input: RelationshipWriteRequest, callback: (err: grpc.ServiceError | null, value?: RelationshipWriteResponse) => void): grpc.ClientUnaryCall;
    /**
     * The ReadRelationships RPC method reads relation tuple(s).
     *
     * @generated from protobuf rpc: ReadRelationships(base.v1.RelationshipReadRequest) returns (base.v1.RelationshipReadResponse);
     */
    readRelationships(input: RelationshipReadRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: RelationshipReadResponse) => void): grpc.ClientUnaryCall;
    readRelationships(input: RelationshipReadRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: RelationshipReadResponse) => void): grpc.ClientUnaryCall;
    readRelationships(input: RelationshipReadRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: RelationshipReadResponse) => void): grpc.ClientUnaryCall;
    readRelationships(input: RelationshipReadRequest, callback: (err: grpc.ServiceError | null, value?: RelationshipReadResponse) => void): grpc.ClientUnaryCall;
    /**
     * The ReadAttributes RPC method reads attribute(s) of a relation.
     *
     * @generated from protobuf rpc: ReadAttributes(base.v1.AttributeReadRequest) returns (base.v1.AttributeReadResponse);
     */
    readAttributes(input: AttributeReadRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: AttributeReadResponse) => void): grpc.ClientUnaryCall;
    readAttributes(input: AttributeReadRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: AttributeReadResponse) => void): grpc.ClientUnaryCall;
    readAttributes(input: AttributeReadRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: AttributeReadResponse) => void): grpc.ClientUnaryCall;
    readAttributes(input: AttributeReadRequest, callback: (err: grpc.ServiceError | null, value?: AttributeReadResponse) => void): grpc.ClientUnaryCall;
    /**
     * The Delete RPC method deletes a relation tuple.
     *
     * @generated from protobuf rpc: Delete(base.v1.DataDeleteRequest) returns (base.v1.DataDeleteResponse);
     */
    delete(input: DataDeleteRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DataDeleteResponse) => void): grpc.ClientUnaryCall;
    delete(input: DataDeleteRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: DataDeleteResponse) => void): grpc.ClientUnaryCall;
    delete(input: DataDeleteRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: DataDeleteResponse) => void): grpc.ClientUnaryCall;
    delete(input: DataDeleteRequest, callback: (err: grpc.ServiceError | null, value?: DataDeleteResponse) => void): grpc.ClientUnaryCall;
    /**
     * RPC method to delete relationships for a tenant, accessed via a POST request to the specified path, tagged as "Data" in OpenAPI documentation.
     *
     * @generated from protobuf rpc: DeleteRelationships(base.v1.RelationshipDeleteRequest) returns (base.v1.RelationshipDeleteResponse);
     */
    deleteRelationships(input: RelationshipDeleteRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: RelationshipDeleteResponse) => void): grpc.ClientUnaryCall;
    deleteRelationships(input: RelationshipDeleteRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: RelationshipDeleteResponse) => void): grpc.ClientUnaryCall;
    deleteRelationships(input: RelationshipDeleteRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: RelationshipDeleteResponse) => void): grpc.ClientUnaryCall;
    deleteRelationships(input: RelationshipDeleteRequest, callback: (err: grpc.ServiceError | null, value?: RelationshipDeleteResponse) => void): grpc.ClientUnaryCall;
    /**
     * Executes or runs a specific bundle. This method is useful for processing or triggering actions based on the bundle's data.
     *
     * @generated from protobuf rpc: RunBundle(base.v1.BundleRunRequest) returns (base.v1.BundleRunResponse);
     */
    runBundle(input: BundleRunRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: BundleRunResponse) => void): grpc.ClientUnaryCall;
    runBundle(input: BundleRunRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: BundleRunResponse) => void): grpc.ClientUnaryCall;
    runBundle(input: BundleRunRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: BundleRunResponse) => void): grpc.ClientUnaryCall;
    runBundle(input: BundleRunRequest, callback: (err: grpc.ServiceError | null, value?: BundleRunResponse) => void): grpc.ClientUnaryCall;
}
// ** DATA SERVICE **

/**
 * The Data service provides RPC methods for managing data in the context of relationships and attributes.
 *
 * @generated from protobuf service base.v1.Data
 */
export class DataClient extends grpc.Client implements IDataClient {
    private readonly _binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions>;
    constructor(address: string, credentials: grpc.ChannelCredentials, options: grpc.ClientOptions = {}, binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions> = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     * The Write RPC method creates a new relation tuple.
     *
     * @generated from protobuf rpc: Write(base.v1.DataWriteRequest) returns (base.v1.DataWriteResponse);
     */
    write(input: DataWriteRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DataWriteResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DataWriteResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: DataWriteResponse) => void)): grpc.ClientUnaryCall {
        const method = Data.methods[0];
        return this.makeUnaryRequest<DataWriteRequest, DataWriteResponse>(`/${Data.typeName}/${method.name}`, (value: DataWriteRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): DataWriteResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * RPC method to write relationships for a tenant. This can be accessed via a POST request to the given HTTP path. It's tagged under "Data" in OpenAPI documentation.
     *
     * @generated from protobuf rpc: WriteRelationships(base.v1.RelationshipWriteRequest) returns (base.v1.RelationshipWriteResponse);
     */
    writeRelationships(input: RelationshipWriteRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: RelationshipWriteResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: RelationshipWriteResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: RelationshipWriteResponse) => void)): grpc.ClientUnaryCall {
        const method = Data.methods[1];
        return this.makeUnaryRequest<RelationshipWriteRequest, RelationshipWriteResponse>(`/${Data.typeName}/${method.name}`, (value: RelationshipWriteRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): RelationshipWriteResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * The ReadRelationships RPC method reads relation tuple(s).
     *
     * @generated from protobuf rpc: ReadRelationships(base.v1.RelationshipReadRequest) returns (base.v1.RelationshipReadResponse);
     */
    readRelationships(input: RelationshipReadRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: RelationshipReadResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: RelationshipReadResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: RelationshipReadResponse) => void)): grpc.ClientUnaryCall {
        const method = Data.methods[2];
        return this.makeUnaryRequest<RelationshipReadRequest, RelationshipReadResponse>(`/${Data.typeName}/${method.name}`, (value: RelationshipReadRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): RelationshipReadResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * The ReadAttributes RPC method reads attribute(s) of a relation.
     *
     * @generated from protobuf rpc: ReadAttributes(base.v1.AttributeReadRequest) returns (base.v1.AttributeReadResponse);
     */
    readAttributes(input: AttributeReadRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: AttributeReadResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: AttributeReadResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: AttributeReadResponse) => void)): grpc.ClientUnaryCall {
        const method = Data.methods[3];
        return this.makeUnaryRequest<AttributeReadRequest, AttributeReadResponse>(`/${Data.typeName}/${method.name}`, (value: AttributeReadRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): AttributeReadResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * The Delete RPC method deletes a relation tuple.
     *
     * @generated from protobuf rpc: Delete(base.v1.DataDeleteRequest) returns (base.v1.DataDeleteResponse);
     */
    delete(input: DataDeleteRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DataDeleteResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: DataDeleteResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: DataDeleteResponse) => void)): grpc.ClientUnaryCall {
        const method = Data.methods[4];
        return this.makeUnaryRequest<DataDeleteRequest, DataDeleteResponse>(`/${Data.typeName}/${method.name}`, (value: DataDeleteRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): DataDeleteResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * RPC method to delete relationships for a tenant, accessed via a POST request to the specified path, tagged as "Data" in OpenAPI documentation.
     *
     * @generated from protobuf rpc: DeleteRelationships(base.v1.RelationshipDeleteRequest) returns (base.v1.RelationshipDeleteResponse);
     */
    deleteRelationships(input: RelationshipDeleteRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: RelationshipDeleteResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: RelationshipDeleteResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: RelationshipDeleteResponse) => void)): grpc.ClientUnaryCall {
        const method = Data.methods[5];
        return this.makeUnaryRequest<RelationshipDeleteRequest, RelationshipDeleteResponse>(`/${Data.typeName}/${method.name}`, (value: RelationshipDeleteRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): RelationshipDeleteResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * Executes or runs a specific bundle. This method is useful for processing or triggering actions based on the bundle's data.
     *
     * @generated from protobuf rpc: RunBundle(base.v1.BundleRunRequest) returns (base.v1.BundleRunResponse);
     */
    runBundle(input: BundleRunRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: BundleRunResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: BundleRunResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: BundleRunResponse) => void)): grpc.ClientUnaryCall {
        const method = Data.methods[6];
        return this.makeUnaryRequest<BundleRunRequest, BundleRunResponse>(`/${Data.typeName}/${method.name}`, (value: BundleRunRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): BundleRunResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
}
// ** BUNDLE SERVICE **

/**
 * @generated from protobuf service base.v1.Bundle
 */
export interface IBundleClient {
    /**
     * Writes a bundle of data for a specific operation. This is a general purpose method to handle writing data bundles.
     *
     * @generated from protobuf rpc: Write(base.v1.BundleWriteRequest) returns (base.v1.BundleWriteResponse);
     */
    write(input: BundleWriteRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: BundleWriteResponse) => void): grpc.ClientUnaryCall;
    write(input: BundleWriteRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: BundleWriteResponse) => void): grpc.ClientUnaryCall;
    write(input: BundleWriteRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: BundleWriteResponse) => void): grpc.ClientUnaryCall;
    write(input: BundleWriteRequest, callback: (err: grpc.ServiceError | null, value?: BundleWriteResponse) => void): grpc.ClientUnaryCall;
    /**
     * Reads a data bundle based on a specified request. This method is tailored for retrieving data bundles.
     *
     * @generated from protobuf rpc: Read(base.v1.BundleReadRequest) returns (base.v1.BundleReadResponse);
     */
    read(input: BundleReadRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: BundleReadResponse) => void): grpc.ClientUnaryCall;
    read(input: BundleReadRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: BundleReadResponse) => void): grpc.ClientUnaryCall;
    read(input: BundleReadRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: BundleReadResponse) => void): grpc.ClientUnaryCall;
    read(input: BundleReadRequest, callback: (err: grpc.ServiceError | null, value?: BundleReadResponse) => void): grpc.ClientUnaryCall;
    /**
     * Deletes a specific data bundle. This method is used to remove existing bundles from the system.
     *
     * @generated from protobuf rpc: Delete(base.v1.BundleDeleteRequest) returns (base.v1.BundleDeleteResponse);
     */
    delete(input: BundleDeleteRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: BundleDeleteResponse) => void): grpc.ClientUnaryCall;
    delete(input: BundleDeleteRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: BundleDeleteResponse) => void): grpc.ClientUnaryCall;
    delete(input: BundleDeleteRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: BundleDeleteResponse) => void): grpc.ClientUnaryCall;
    delete(input: BundleDeleteRequest, callback: (err: grpc.ServiceError | null, value?: BundleDeleteResponse) => void): grpc.ClientUnaryCall;
}
// ** BUNDLE SERVICE **

/**
 * @generated from protobuf service base.v1.Bundle
 */
export class BundleClient extends grpc.Client implements IBundleClient {
    private readonly _binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions>;
    constructor(address: string, credentials: grpc.ChannelCredentials, options: grpc.ClientOptions = {}, binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions> = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     * Writes a bundle of data for a specific operation. This is a general purpose method to handle writing data bundles.
     *
     * @generated from protobuf rpc: Write(base.v1.BundleWriteRequest) returns (base.v1.BundleWriteResponse);
     */
    write(input: BundleWriteRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: BundleWriteResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: BundleWriteResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: BundleWriteResponse) => void)): grpc.ClientUnaryCall {
        const method = Bundle.methods[0];
        return this.makeUnaryRequest<BundleWriteRequest, BundleWriteResponse>(`/${Bundle.typeName}/${method.name}`, (value: BundleWriteRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): BundleWriteResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * Reads a data bundle based on a specified request. This method is tailored for retrieving data bundles.
     *
     * @generated from protobuf rpc: Read(base.v1.BundleReadRequest) returns (base.v1.BundleReadResponse);
     */
    read(input: BundleReadRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: BundleReadResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: BundleReadResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: BundleReadResponse) => void)): grpc.ClientUnaryCall {
        const method = Bundle.methods[1];
        return this.makeUnaryRequest<BundleReadRequest, BundleReadResponse>(`/${Bundle.typeName}/${method.name}`, (value: BundleReadRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): BundleReadResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * Deletes a specific data bundle. This method is used to remove existing bundles from the system.
     *
     * @generated from protobuf rpc: Delete(base.v1.BundleDeleteRequest) returns (base.v1.BundleDeleteResponse);
     */
    delete(input: BundleDeleteRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: BundleDeleteResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: BundleDeleteResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: BundleDeleteResponse) => void)): grpc.ClientUnaryCall {
        const method = Bundle.methods[2];
        return this.makeUnaryRequest<BundleDeleteRequest, BundleDeleteResponse>(`/${Bundle.typeName}/${method.name}`, (value: BundleDeleteRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): BundleDeleteResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
}
// ** TENANCY SERVICE **
// The Tenancy service defines the gRPC methods for managing tenants.

/**
 * @generated from protobuf service base.v1.Tenancy
 */
export interface ITenancyClient {
    /**
     * Create is a unary RPC to create a new tenant.
     * It requires a TenantCreateRequest and returns a TenantCreateResponse.
     *
     * @generated from protobuf rpc: Create(base.v1.TenantCreateRequest) returns (base.v1.TenantCreateResponse);
     */
    create(input: TenantCreateRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: TenantCreateResponse) => void): grpc.ClientUnaryCall;
    create(input: TenantCreateRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: TenantCreateResponse) => void): grpc.ClientUnaryCall;
    create(input: TenantCreateRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: TenantCreateResponse) => void): grpc.ClientUnaryCall;
    create(input: TenantCreateRequest, callback: (err: grpc.ServiceError | null, value?: TenantCreateResponse) => void): grpc.ClientUnaryCall;
    /**
     * Delete is a unary RPC to delete an existing tenant.
     * It requires a TenantDeleteRequest and returns a TenantDeleteResponse.
     *
     * @generated from protobuf rpc: Delete(base.v1.TenantDeleteRequest) returns (base.v1.TenantDeleteResponse);
     */
    delete(input: TenantDeleteRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: TenantDeleteResponse) => void): grpc.ClientUnaryCall;
    delete(input: TenantDeleteRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: TenantDeleteResponse) => void): grpc.ClientUnaryCall;
    delete(input: TenantDeleteRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: TenantDeleteResponse) => void): grpc.ClientUnaryCall;
    delete(input: TenantDeleteRequest, callback: (err: grpc.ServiceError | null, value?: TenantDeleteResponse) => void): grpc.ClientUnaryCall;
    /**
     * List is a unary RPC to get a list of all tenants.
     * It requires a TenantListRequest and returns a TenantListResponse.
     *
     * @generated from protobuf rpc: List(base.v1.TenantListRequest) returns (base.v1.TenantListResponse);
     */
    list(input: TenantListRequest, metadata: grpc.Metadata, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: TenantListResponse) => void): grpc.ClientUnaryCall;
    list(input: TenantListRequest, metadata: grpc.Metadata, callback: (err: grpc.ServiceError | null, value?: TenantListResponse) => void): grpc.ClientUnaryCall;
    list(input: TenantListRequest, options: grpc.CallOptions, callback: (err: grpc.ServiceError | null, value?: TenantListResponse) => void): grpc.ClientUnaryCall;
    list(input: TenantListRequest, callback: (err: grpc.ServiceError | null, value?: TenantListResponse) => void): grpc.ClientUnaryCall;
}
// ** TENANCY SERVICE **
// The Tenancy service defines the gRPC methods for managing tenants.

/**
 * @generated from protobuf service base.v1.Tenancy
 */
export class TenancyClient extends grpc.Client implements ITenancyClient {
    private readonly _binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions>;
    constructor(address: string, credentials: grpc.ChannelCredentials, options: grpc.ClientOptions = {}, binaryOptions: Partial<BinaryReadOptions & BinaryWriteOptions> = {}) {
        super(address, credentials, options);
        this._binaryOptions = binaryOptions;
    }
    /**
     * Create is a unary RPC to create a new tenant.
     * It requires a TenantCreateRequest and returns a TenantCreateResponse.
     *
     * @generated from protobuf rpc: Create(base.v1.TenantCreateRequest) returns (base.v1.TenantCreateResponse);
     */
    create(input: TenantCreateRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: TenantCreateResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: TenantCreateResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: TenantCreateResponse) => void)): grpc.ClientUnaryCall {
        const method = Tenancy.methods[0];
        return this.makeUnaryRequest<TenantCreateRequest, TenantCreateResponse>(`/${Tenancy.typeName}/${method.name}`, (value: TenantCreateRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): TenantCreateResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * Delete is a unary RPC to delete an existing tenant.
     * It requires a TenantDeleteRequest and returns a TenantDeleteResponse.
     *
     * @generated from protobuf rpc: Delete(base.v1.TenantDeleteRequest) returns (base.v1.TenantDeleteResponse);
     */
    delete(input: TenantDeleteRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: TenantDeleteResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: TenantDeleteResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: TenantDeleteResponse) => void)): grpc.ClientUnaryCall {
        const method = Tenancy.methods[1];
        return this.makeUnaryRequest<TenantDeleteRequest, TenantDeleteResponse>(`/${Tenancy.typeName}/${method.name}`, (value: TenantDeleteRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): TenantDeleteResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
    /**
     * List is a unary RPC to get a list of all tenants.
     * It requires a TenantListRequest and returns a TenantListResponse.
     *
     * @generated from protobuf rpc: List(base.v1.TenantListRequest) returns (base.v1.TenantListResponse);
     */
    list(input: TenantListRequest, metadata: grpc.Metadata | grpc.CallOptions | ((err: grpc.ServiceError | null, value?: TenantListResponse) => void), options?: grpc.CallOptions | ((err: grpc.ServiceError | null, value?: TenantListResponse) => void), callback?: ((err: grpc.ServiceError | null, value?: TenantListResponse) => void)): grpc.ClientUnaryCall {
        const method = Tenancy.methods[2];
        return this.makeUnaryRequest<TenantListRequest, TenantListResponse>(`/${Tenancy.typeName}/${method.name}`, (value: TenantListRequest): Buffer => Buffer.from(method.I.toBinary(value, this._binaryOptions)), (value: Buffer): TenantListResponse => method.O.fromBinary(value, this._binaryOptions), input, (metadata as any), (options as any), (callback as any));
    }
}
