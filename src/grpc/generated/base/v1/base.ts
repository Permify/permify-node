// @generated by protobuf-ts 2.9.1 with parameter long_type_string,client_grpc1,generate_dependencies
// @generated from protobuf file "base/v1/base.proto" (package "base.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Any } from "../../google/protobuf/any";
import { CheckedExpr } from "../../google/api/expr/v1alpha1/checked";
import { Struct } from "../../google/protobuf/struct";
/**
 * Context encapsulates the information related to a single operation,
 * including the tuples involved and the associated attributes.
 *
 * @generated from protobuf message base.v1.Context
 */
export interface Context {
    /**
     * A repeated field of tuples involved in the operation.
     *
     * @generated from protobuf field: repeated base.v1.Tuple tuples = 1;
     */
    tuples: Tuple[];
    /**
     * A repeated field of attributes associated with the operation.
     *
     * @generated from protobuf field: repeated base.v1.Attribute attributes = 2;
     */
    attributes: Attribute[];
    /**
     * Additional data associated with the context.
     *
     * @generated from protobuf field: google.protobuf.Struct data = 3;
     */
    data?: Struct;
}
/**
 * Child represents a node in the permission tree.
 *
 * @generated from protobuf message base.v1.Child
 */
export interface Child {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "leaf";
        /**
         * Leaf node in the permission tree.
         *
         * @generated from protobuf field: base.v1.Leaf leaf = 1;
         */
        leaf: Leaf;
    } | {
        oneofKind: "rewrite";
        /**
         * Rewrite operation in the permission tree.
         *
         * @generated from protobuf field: base.v1.Rewrite rewrite = 2;
         */
        rewrite: Rewrite;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Leaf represents a leaf node in the permission tree.
 *
 * @generated from protobuf message base.v1.Leaf
 */
export interface Leaf {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "computedUserSet";
        /**
         * A computed set of users.
         *
         * @generated from protobuf field: base.v1.ComputedUserSet computed_user_set = 1;
         */
        computedUserSet: ComputedUserSet;
    } | {
        oneofKind: "tupleToUserSet";
        /**
         * A tuple to user set conversion.
         *
         * @generated from protobuf field: base.v1.TupleToUserSet tuple_to_user_set = 2;
         */
        tupleToUserSet: TupleToUserSet;
    } | {
        oneofKind: "computedAttribute";
        /**
         * A computed attribute.
         *
         * @generated from protobuf field: base.v1.ComputedAttribute computed_attribute = 3;
         */
        computedAttribute: ComputedAttribute;
    } | {
        oneofKind: "call";
        /**
         * A call to a function or method.
         *
         * @generated from protobuf field: base.v1.Call call = 4;
         */
        call: Call;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The Rewrite message represents a specific rewrite operation.
 * This operation could be one of the following: union, intersection, or exclusion.
 *
 * @generated from protobuf message base.v1.Rewrite
 */
export interface Rewrite {
    /**
     * The type of rewrite operation to be performed.
     *
     * @generated from protobuf field: base.v1.Rewrite.Operation rewrite_operation = 1;
     */
    rewriteOperation: Rewrite_Operation;
    /**
     * A list of children that are operated upon by the rewrite operation.
     *
     * @generated from protobuf field: repeated base.v1.Child children = 2;
     */
    children: Child[];
}
/**
 * Operation enum includes potential rewrite operations.
 * OPERATION_UNION: Represents a union operation.
 * OPERATION_INTERSECTION: Represents an intersection operation.
 * OPERATION_EXCLUSION: Represents an exclusion operation.
 *
 * @generated from protobuf enum base.v1.Rewrite.Operation
 */
export enum Rewrite_Operation {
    /**
     * Default, unspecified operation.
     *
     * @generated from protobuf enum value: OPERATION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Represents a union operation.
     *
     * @generated from protobuf enum value: OPERATION_UNION = 1;
     */
    UNION = 1,
    /**
     * Represents an intersection operation.
     *
     * @generated from protobuf enum value: OPERATION_INTERSECTION = 2;
     */
    INTERSECTION = 2,
    /**
     * Represents an exclusion operation.
     *
     * @generated from protobuf enum value: OPERATION_EXCLUSION = 3;
     */
    EXCLUSION = 3
}
/**
 * The SchemaDefinition message provides definitions for entities and rules,
 * and includes references to clarify whether a name refers to an entity or a rule.
 *
 * @generated from protobuf message base.v1.SchemaDefinition
 */
export interface SchemaDefinition {
    /**
     * Map of entity definitions. The key is the entity name, and the value is the corresponding EntityDefinition.
     *
     * @generated from protobuf field: map<string, base.v1.EntityDefinition> entity_definitions = 1;
     */
    entityDefinitions: {
        [key: string]: EntityDefinition;
    };
    /**
     * Map of rule definitions. The key is the rule name, and the value is the corresponding RuleDefinition.
     *
     * @generated from protobuf field: map<string, base.v1.RuleDefinition> rule_definitions = 2;
     */
    ruleDefinitions: {
        [key: string]: RuleDefinition;
    };
    /**
     * Map of references to signify whether a string refers to an entity or a rule.
     *
     * @generated from protobuf field: map<string, base.v1.SchemaDefinition.Reference> references = 3;
     */
    references: {
        [key: string]: SchemaDefinition_Reference;
    };
}
/**
 * The Reference enum helps distinguish whether a name corresponds to an entity or a rule.
 *
 * @generated from protobuf enum base.v1.SchemaDefinition.Reference
 */
export enum SchemaDefinition_Reference {
    /**
     * Default, unspecified reference.
     *
     * @generated from protobuf enum value: REFERENCE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Indicates that the name refers to an entity.
     *
     * @generated from protobuf enum value: REFERENCE_ENTITY = 1;
     */
    ENTITY = 1,
    /**
     * Indicates that the name refers to a rule.
     *
     * @generated from protobuf enum value: REFERENCE_RULE = 2;
     */
    RULE = 2
}
/**
 * The EntityDefinition message provides detailed information about a specific entity.
 *
 * @generated from protobuf message base.v1.EntityDefinition
 */
export interface EntityDefinition {
    /**
     * The name of the entity, which follows a specific string pattern and has a maximum byte size.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Map of relation definitions within this entity. The key is the relation name, and the value is the RelationDefinition.
     *
     * @generated from protobuf field: map<string, base.v1.RelationDefinition> relations = 2;
     */
    relations: {
        [key: string]: RelationDefinition;
    };
    /**
     * Map of permission definitions within this entity. The key is the permission name, and the value is the PermissionDefinition.
     *
     * @generated from protobuf field: map<string, base.v1.PermissionDefinition> permissions = 3;
     */
    permissions: {
        [key: string]: PermissionDefinition;
    };
    /**
     * Map of attribute definitions within this entity. The key is the attribute name, and the value is the AttributeDefinition.
     *
     * @generated from protobuf field: map<string, base.v1.AttributeDefinition> attributes = 4;
     */
    attributes: {
        [key: string]: AttributeDefinition;
    };
    /**
     * Map of references indicating whether a string pertains to a relation, permission, or attribute.
     *
     * @generated from protobuf field: map<string, base.v1.EntityDefinition.Reference> references = 5;
     */
    references: {
        [key: string]: EntityDefinition_Reference;
    };
}
/**
 * The Reference enum specifies whether a name pertains to a relation, permission, or attribute.
 *
 * @generated from protobuf enum base.v1.EntityDefinition.Reference
 */
export enum EntityDefinition_Reference {
    /**
     * Default, unspecified reference.
     *
     * @generated from protobuf enum value: REFERENCE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Indicates that the name refers to a relation.
     *
     * @generated from protobuf enum value: REFERENCE_RELATION = 1;
     */
    RELATION = 1,
    /**
     * Indicates that the name refers to a permission.
     *
     * @generated from protobuf enum value: REFERENCE_PERMISSION = 2;
     */
    PERMISSION = 2,
    /**
     * Indicates that the name refers to an attribute.
     *
     * @generated from protobuf enum value: REFERENCE_ATTRIBUTE = 3;
     */
    ATTRIBUTE = 3
}
/**
 * The RuleDefinition message provides detailed information about a specific rule.
 *
 * @generated from protobuf message base.v1.RuleDefinition
 */
export interface RuleDefinition {
    /**
     * The name of the rule, which follows a specific string pattern and has a maximum byte size.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Map of arguments for this rule. The key is the attribute name, and the value is the AttributeType.
     *
     * @generated from protobuf field: map<string, base.v1.AttributeType> arguments = 2;
     */
    arguments: {
        [key: string]: AttributeType;
    };
    /**
     * The expression for this rule in the form of a google.api.expr.v1alpha1.CheckedExpr.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.CheckedExpr expression = 3;
     */
    expression?: CheckedExpr;
}
/**
 * The AttributeDefinition message provides detailed information about a specific attribute.
 *
 * @generated from protobuf message base.v1.AttributeDefinition
 */
export interface AttributeDefinition {
    /**
     * The name of the attribute, which follows a specific string pattern and has a maximum byte size.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The type of the attribute.
     *
     * @generated from protobuf field: base.v1.AttributeType type = 2;
     */
    type: AttributeType;
}
/**
 * The RelationDefinition message provides detailed information about a specific relation.
 *
 * @generated from protobuf message base.v1.RelationDefinition
 */
export interface RelationDefinition {
    /**
     * The name of the relation, which follows a specific string pattern and has a maximum byte size.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * A list of references to other relations.
     *
     * @generated from protobuf field: repeated base.v1.RelationReference relation_references = 2;
     */
    relationReferences: RelationReference[];
}
/**
 * The PermissionDefinition message provides detailed information about a specific permission.
 *
 * @generated from protobuf message base.v1.PermissionDefinition
 */
export interface PermissionDefinition {
    /**
     * The name of the permission, which follows a specific string pattern and has a maximum byte size.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The child related to this permission.
     *
     * @generated from protobuf field: base.v1.Child child = 2;
     */
    child?: Child;
}
/**
 * The RelationReference message provides a reference to a specific relation.
 *
 * @generated from protobuf message base.v1.RelationReference
 */
export interface RelationReference {
    /**
     * The type of the referenced entity, which follows a specific string pattern and has a maximum byte size.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * The name of the referenced relation, which follows a specific string pattern and has a maximum byte size.
     *
     * @generated from protobuf field: string relation = 2;
     */
    relation: string;
}
/**
 * @generated from protobuf message base.v1.Entrance
 */
export interface Entrance {
    /**
     * The type of the entrance entity, which follows a specific string pattern and has a maximum byte size.
     *
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * The value associated with the entrance, which follows a specific string pattern and has a maximum byte size.
     *
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * Argument defines the type of argument in a Call. It can be either a ComputedAttribute or a ContextAttribute.
 *
 * @generated from protobuf message base.v1.Argument
 */
export interface Argument {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "computedAttribute";
        /**
         * @generated from protobuf field: base.v1.ComputedAttribute computed_attribute = 1;
         */
        computedAttribute: ComputedAttribute;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Call represents a call to a rule. It includes the name of the rule and the arguments passed to it.
 *
 * @generated from protobuf message base.v1.Call
 */
export interface Call {
    /**
     * @generated from protobuf field: string rule_name = 1;
     */
    ruleName: string; // Name of the rule
    /**
     * @generated from protobuf field: repeated base.v1.Argument arguments = 2;
     */
    arguments: Argument[]; // Arguments passed to the rule
}
/**
 * ComputedAttribute defines a computed attribute which includes its name.
 *
 * @generated from protobuf message base.v1.ComputedAttribute
 */
export interface ComputedAttribute {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string; // Name of the computed attribute
}
/**
 * ComputedUserSet defines a set of computed users which includes the relation name.
 *
 * @generated from protobuf message base.v1.ComputedUserSet
 */
export interface ComputedUserSet {
    /**
     * @generated from protobuf field: string relation = 1;
     */
    relation: string; // Relation name
}
/**
 * TupleToUserSet defines a mapping from tuple sets to computed user sets.
 *
 * @generated from protobuf message base.v1.TupleToUserSet
 */
export interface TupleToUserSet {
    /**
     * @generated from protobuf field: base.v1.TupleSet tupleSet = 1;
     */
    tupleSet?: TupleSet; // The tuple set
    /**
     * @generated from protobuf field: base.v1.ComputedUserSet computed = 2;
     */
    computed?: ComputedUserSet; // The computed user set
}
/**
 * TupleSet represents a set of tuples associated with a specific relation.
 *
 * @generated from protobuf message base.v1.TupleSet
 */
export interface TupleSet {
    /**
     * @generated from protobuf field: string relation = 1;
     */
    relation: string;
}
/**
 * Tuple is a structure that includes an entity, a relation, and a subject.
 *
 * @generated from protobuf message base.v1.Tuple
 */
export interface Tuple {
    /**
     * @generated from protobuf field: base.v1.Entity entity = 1;
     */
    entity?: Entity;
    /**
     * @generated from protobuf field: string relation = 2;
     */
    relation: string;
    /**
     * @generated from protobuf field: base.v1.Subject subject = 3;
     */
    subject?: Subject;
}
/**
 * Attribute represents an attribute of an entity with a specific type and value.
 *
 * @generated from protobuf message base.v1.Attribute
 */
export interface Attribute {
    /**
     * @generated from protobuf field: base.v1.Entity entity = 1;
     */
    entity?: Entity;
    /**
     * @generated from protobuf field: string attribute = 2;
     */
    attribute: string; // Name of the attribute
    /**
     * @generated from protobuf field: google.protobuf.Any value = 3;
     */
    value?: Any;
}
/**
 * Tuples is a collection of tuples.
 *
 * @generated from protobuf message base.v1.Tuples
 */
export interface Tuples {
    /**
     * @generated from protobuf field: repeated base.v1.Tuple tuples = 1;
     */
    tuples: Tuple[];
}
/**
 * Attributes is a collection of attributes.
 *
 * @generated from protobuf message base.v1.Attributes
 */
export interface Attributes {
    /**
     * @generated from protobuf field: repeated base.v1.Attribute attributes = 1;
     */
    attributes: Attribute[];
}
/**
 * Entity represents an entity with a type and an identifier.
 *
 * @generated from protobuf message base.v1.Entity
 */
export interface Entity {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
}
/**
 * EntityAndRelation represents an entity along with a relation.
 *
 * @generated from protobuf message base.v1.EntityAndRelation
 */
export interface EntityAndRelation {
    /**
     * @generated from protobuf field: base.v1.Entity entity = 1;
     */
    entity?: Entity;
    /**
     * @generated from protobuf field: string relation = 2;
     */
    relation: string;
}
/**
 * Subject represents an entity subject with a type, an identifier, and a relation.
 *
 * @generated from protobuf message base.v1.Subject
 */
export interface Subject {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string;
    /**
     * @generated from protobuf field: string id = 2;
     */
    id: string;
    /**
     * @generated from protobuf field: string relation = 3;
     */
    relation: string;
}
/**
 * AttributeFilter is used to filter attributes based on the entity and attribute names.
 *
 * @generated from protobuf message base.v1.AttributeFilter
 */
export interface AttributeFilter {
    /**
     * @generated from protobuf field: base.v1.EntityFilter entity = 1;
     */
    entity?: EntityFilter;
    /**
     * @generated from protobuf field: repeated string attributes = 2;
     */
    attributes: string[]; // Names of the attributes to be filtered
}
/**
 * TupleFilter is used to filter tuples based on the entity, relation and the subject.
 *
 * @generated from protobuf message base.v1.TupleFilter
 */
export interface TupleFilter {
    /**
     * @generated from protobuf field: base.v1.EntityFilter entity = 1;
     */
    entity?: EntityFilter;
    /**
     * @generated from protobuf field: string relation = 2;
     */
    relation: string;
    /**
     * @generated from protobuf field: base.v1.SubjectFilter subject = 3;
     */
    subject?: SubjectFilter; // The subject filter
}
/**
 * EntityFilter is used to filter entities based on the type and ids.
 *
 * @generated from protobuf message base.v1.EntityFilter
 */
export interface EntityFilter {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string; // Type of the entity
    /**
     * @generated from protobuf field: repeated string ids = 2;
     */
    ids: string[]; // List of entity IDs
}
/**
 * SubjectFilter is used to filter subjects based on the type, ids and relation.
 *
 * @generated from protobuf message base.v1.SubjectFilter
 */
export interface SubjectFilter {
    /**
     * @generated from protobuf field: string type = 1;
     */
    type: string; // Type of the subject
    /**
     * @generated from protobuf field: repeated string ids = 2;
     */
    ids: string[]; // List of subject IDs
    /**
     * @generated from protobuf field: string relation = 3;
     */
    relation: string;
}
/**
 * ExpandTreeNode represents a node in an expansion tree with a specific operation and its children.
 *
 * @generated from protobuf message base.v1.ExpandTreeNode
 */
export interface ExpandTreeNode {
    /**
     * @generated from protobuf field: base.v1.ExpandTreeNode.Operation operation = 1;
     */
    operation: ExpandTreeNode_Operation; // Operation to be applied on this tree node
    /**
     * @generated from protobuf field: repeated base.v1.Expand children = 2;
     */
    children: Expand[]; // The children of this tree node
}
/**
 * Operation is an enum representing the type of operation to be applied on the tree node.
 *
 * @generated from protobuf enum base.v1.ExpandTreeNode.Operation
 */
export enum ExpandTreeNode_Operation {
    /**
     * @generated from protobuf enum value: OPERATION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: OPERATION_UNION = 1;
     */
    UNION = 1,
    /**
     * @generated from protobuf enum value: OPERATION_INTERSECTION = 2;
     */
    INTERSECTION = 2,
    /**
     * @generated from protobuf enum value: OPERATION_EXCLUSION = 3;
     */
    EXCLUSION = 3
}
/**
 * Expand is used to define a hierarchical structure for permissions.
 * It has an entity, permission, and arguments. The node can be either another hierarchical structure or a set of subjects.
 *
 * @generated from protobuf message base.v1.Expand
 */
export interface Expand {
    /**
     * entity is the entity for which the hierarchical structure is defined.
     *
     * @generated from protobuf field: base.v1.Entity entity = 1;
     */
    entity?: Entity;
    /**
     * permission is the permission applied to the entity.
     *
     * @generated from protobuf field: string permission = 2;
     */
    permission: string;
    /**
     * arguments are the additional information or context used to evaluate permissions.
     *
     * @generated from protobuf field: repeated base.v1.Argument arguments = 3;
     */
    arguments: Argument[];
    /**
     * @generated from protobuf oneof: node
     */
    node: {
        oneofKind: "expand";
        /**
         * expand contains another hierarchical structure.
         *
         * @generated from protobuf field: base.v1.ExpandTreeNode expand = 4;
         */
        expand: ExpandTreeNode;
    } | {
        oneofKind: "leaf";
        /**
         * leaf contains a set of subjects.
         *
         * @generated from protobuf field: base.v1.ExpandLeaf leaf = 5;
         */
        leaf: ExpandLeaf;
    } | {
        oneofKind: undefined;
    };
}
/**
 * ExpandLeaf is the leaf node of an Expand tree and can be either a set of Subjects or a set of Values.
 *
 * @generated from protobuf message base.v1.ExpandLeaf
 */
export interface ExpandLeaf {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "subjects";
        /**
         * subjects are used when the leaf is a set of subjects.
         *
         * @generated from protobuf field: base.v1.Subjects subjects = 1;
         */
        subjects: Subjects;
    } | {
        oneofKind: "values";
        /**
         * values are used when the leaf node is a set of values.
         *
         * @generated from protobuf field: base.v1.Values values = 2;
         */
        values: Values;
    } | {
        oneofKind: "value";
        /**
         * value is used when the leaf node is a single value.
         *
         * @generated from protobuf field: google.protobuf.Any value = 3;
         */
        value: Any;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message base.v1.Values
 */
export interface Values {
    /**
     * @generated from protobuf field: map<string, google.protobuf.Any> values = 1;
     */
    values: {
        [key: string]: Any;
    };
}
/**
 * Subjects holds a repeated field of Subject type.
 *
 * @generated from protobuf message base.v1.Subjects
 */
export interface Subjects {
    /**
     * @generated from protobuf field: repeated base.v1.Subject subjects = 1;
     */
    subjects: Subject[]; // A list of subjects.
}
/**
 * Tenant represents a tenant with an id, a name, and a timestamp indicating when it was created.
 *
 * @generated from protobuf message base.v1.Tenant
 */
export interface Tenant {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // The ID of the tenant.
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string; // The name of the tenant.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 3 [json_name = "created_at"];
     */
    createdAt?: Timestamp; // The time at which the tenant was created.
}
/**
 * DataChanges represent changes in data with a snap token and a list of data change objects.
 *
 * @generated from protobuf message base.v1.DataChanges
 */
export interface DataChanges {
    /**
     * @generated from protobuf field: string snap_token = 1 [json_name = "snap_token"];
     */
    snapToken: string; // The snapshot token.
    /**
     * @generated from protobuf field: repeated base.v1.DataChange data_changes = 2 [json_name = "data_changes"];
     */
    dataChanges: DataChange[]; // The list of data changes.
}
/**
 * DataChange represents a single change in data, with an operation type and the actual change which could be a tuple or an attribute.
 *
 * @generated from protobuf message base.v1.DataChange
 */
export interface DataChange {
    /**
     * @generated from protobuf field: base.v1.DataChange.Operation operation = 1;
     */
    operation: DataChange_Operation; // The operation type.
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "tuple";
        /**
         * @generated from protobuf field: base.v1.Tuple tuple = 2;
         */
        tuple: Tuple; // If the change is a tuple.
    } | {
        oneofKind: "attribute";
        /**
         * @generated from protobuf field: base.v1.Attribute attribute = 3;
         */
        attribute: Attribute; // If the change is an attribute.
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum base.v1.DataChange.Operation
 */
export enum DataChange_Operation {
    /**
     * Default operation, not specified.
     *
     * @generated from protobuf enum value: OPERATION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Creation operation.
     *
     * @generated from protobuf enum value: OPERATION_CREATE = 1;
     */
    CREATE = 1,
    /**
     * Deletion operation.
     *
     * @generated from protobuf enum value: OPERATION_DELETE = 2;
     */
    DELETE = 2
}
/**
 * Wrapper for a single string value.
 *
 * @generated from protobuf message base.v1.StringValue
 */
export interface StringValue {
    /**
     * @generated from protobuf field: string data = 1;
     */
    data: string; // The string value.
}
/**
 * Wrapper for a single integer value.
 *
 * @generated from protobuf message base.v1.IntegerValue
 */
export interface IntegerValue {
    /**
     * @generated from protobuf field: int32 data = 1;
     */
    data: number; // The integer value.
}
/**
 * Wrapper for a single double precision floating point value.
 *
 * @generated from protobuf message base.v1.DoubleValue
 */
export interface DoubleValue {
    /**
     * @generated from protobuf field: double data = 1;
     */
    data: number; // The double value.
}
/**
 * Wrapper for a single boolean value.
 *
 * @generated from protobuf message base.v1.BooleanValue
 */
export interface BooleanValue {
    /**
     * @generated from protobuf field: bool data = 1;
     */
    data: boolean; // The boolean value.
}
/**
 * Wrapper for an array of strings.
 *
 * @generated from protobuf message base.v1.StringArrayValue
 */
export interface StringArrayValue {
    /**
     * @generated from protobuf field: repeated string data = 1;
     */
    data: string[]; // The array of strings.
}
/**
 * Wrapper for an array of integers.
 *
 * @generated from protobuf message base.v1.IntegerArrayValue
 */
export interface IntegerArrayValue {
    /**
     * @generated from protobuf field: repeated int32 data = 1;
     */
    data: number[]; // The array of integers.
}
/**
 * Wrapper for an array of double precision floating point values.
 *
 * @generated from protobuf message base.v1.DoubleArrayValue
 */
export interface DoubleArrayValue {
    /**
     * @generated from protobuf field: repeated double data = 1;
     */
    data: number[]; // The array of doubles.
}
/**
 * Wrapper for an array of booleans.
 *
 * @generated from protobuf message base.v1.BooleanArrayValue
 */
export interface BooleanArrayValue {
    /**
     * @generated from protobuf field: repeated bool data = 1;
     */
    data: boolean[]; // The array of booleans.
}
/**
 * DataBundle is a message representing a bundle of data, which includes a name,
 * a list of arguments, and a series of operations.
 *
 * @generated from protobuf message base.v1.DataBundle
 */
export interface DataBundle {
    /**
     * 'name' is a simple string field representing the name of the DataBundle.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * 'arguments' is a repeated field, which means it can contain multiple strings.
     * These are used to store a list of arguments related to the DataBundle.
     *
     * @generated from protobuf field: repeated string arguments = 2;
     */
    arguments: string[];
    /**
     * 'operations' is a repeated field containing multiple Operation messages.
     * Each Operation represents a specific action or set of actions to be performed.
     *
     * @generated from protobuf field: repeated base.v1.Operation operations = 3;
     */
    operations: Operation[];
}
/**
 * Operation is a message representing a series of operations that can be performed.
 * It includes fields for writing and deleting relationships and attributes.
 *
 * @generated from protobuf message base.v1.Operation
 */
export interface Operation {
    /**
     * 'relationships_write' is a repeated string field for storing relationship keys
     * that are to be written or created.
     *
     * @generated from protobuf field: repeated string relationships_write = 1 [json_name = "relationships_write"];
     */
    relationshipsWrite: string[];
    /**
     * 'relationships_delete' is a repeated string field for storing relationship keys
     * that are to be deleted or removed.
     *
     * @generated from protobuf field: repeated string relationships_delete = 2 [json_name = "relationships_delete"];
     */
    relationshipsDelete: string[];
    /**
     * 'attributes_write' is a repeated string field for storing attribute keys
     * that are to be written or created.
     *
     * @generated from protobuf field: repeated string attributes_write = 3 [json_name = "attributes_write"];
     */
    attributesWrite: string[];
    /**
     * 'attributes_delete' is a repeated string field for storing attribute keys
     * that are to be deleted or removed.
     *
     * @generated from protobuf field: repeated string attributes_delete = 4 [json_name = "attributes_delete"];
     */
    attributesDelete: string[];
}
/**
 * Partials contains the write, update and delete definitions
 *
 * @generated from protobuf message base.v1.Partials
 */
export interface Partials {
    /**
     * @generated from protobuf field: repeated string write = 1;
     */
    write: string[];
    /**
     * @generated from protobuf field: repeated string delete = 2;
     */
    delete: string[];
    /**
     * @generated from protobuf field: repeated string update = 3;
     */
    update: string[];
}
/**
 * Enumerates results of a check operation.
 *
 * @generated from protobuf enum base.v1.CheckResult
 */
export enum CheckResult {
    /**
     * Not specified check result. This is the default value.
     *
     * @generated from protobuf enum value: CHECK_RESULT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Represents a successful check (the check allowed the operation).
     *
     * @generated from protobuf enum value: CHECK_RESULT_ALLOWED = 1;
     */
    ALLOWED = 1,
    /**
     * Represents a failed check (the check denied the operation).
     *
     * @generated from protobuf enum value: CHECK_RESULT_DENIED = 2;
     */
    DENIED = 2
}
/**
 * Enumerates the types of attribute.
 *
 * @generated from protobuf enum base.v1.AttributeType
 */
export enum AttributeType {
    /**
     * Not specified attribute type. This is the default value.
     *
     * @generated from protobuf enum value: ATTRIBUTE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * A boolean attribute type.
     *
     * @generated from protobuf enum value: ATTRIBUTE_TYPE_BOOLEAN = 1;
     */
    BOOLEAN = 1,
    /**
     * A boolean array attribute type.
     *
     * @generated from protobuf enum value: ATTRIBUTE_TYPE_BOOLEAN_ARRAY = 2;
     */
    BOOLEAN_ARRAY = 2,
    /**
     * A string attribute type.
     *
     * @generated from protobuf enum value: ATTRIBUTE_TYPE_STRING = 3;
     */
    STRING = 3,
    /**
     * A string array attribute type.
     *
     * @generated from protobuf enum value: ATTRIBUTE_TYPE_STRING_ARRAY = 4;
     */
    STRING_ARRAY = 4,
    /**
     * An integer attribute type.
     *
     * @generated from protobuf enum value: ATTRIBUTE_TYPE_INTEGER = 5;
     */
    INTEGER = 5,
    /**
     * An integer array attribute type.
     *
     * @generated from protobuf enum value: ATTRIBUTE_TYPE_INTEGER_ARRAY = 6;
     */
    INTEGER_ARRAY = 6,
    /**
     * A double attribute type.
     *
     * @generated from protobuf enum value: ATTRIBUTE_TYPE_DOUBLE = 7;
     */
    DOUBLE = 7,
    /**
     * A double array attribute type.
     *
     * @generated from protobuf enum value: ATTRIBUTE_TYPE_DOUBLE_ARRAY = 8;
     */
    DOUBLE_ARRAY = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class Context$Type extends MessageType<Context> {
    constructor() {
        super("base.v1.Context", [
            { no: 1, name: "tuples", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tuple },
            { no: 2, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Attribute },
            { no: 3, name: "data", kind: "message", T: () => Struct }
        ]);
    }
    create(value?: PartialMessage<Context>): Context {
        const message = { tuples: [], attributes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Context>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Context): Context {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated base.v1.Tuple tuples */ 1:
                    message.tuples.push(Tuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated base.v1.Attribute attributes */ 2:
                    message.attributes.push(Attribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Struct data */ 3:
                    message.data = Struct.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Context, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated base.v1.Tuple tuples = 1; */
        for (let i = 0; i < message.tuples.length; i++)
            Tuple.internalBinaryWrite(message.tuples[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated base.v1.Attribute attributes = 2; */
        for (let i = 0; i < message.attributes.length; i++)
            Attribute.internalBinaryWrite(message.attributes[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Struct data = 3; */
        if (message.data)
            Struct.internalBinaryWrite(message.data, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Context
 */
export const Context = new Context$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Child$Type extends MessageType<Child> {
    constructor() {
        super("base.v1.Child", [
            { no: 1, name: "leaf", kind: "message", oneof: "type", T: () => Leaf, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "rewrite", kind: "message", oneof: "type", T: () => Rewrite, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<Child>): Child {
        const message = { type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Child>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Child): Child {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.Leaf leaf */ 1:
                    message.type = {
                        oneofKind: "leaf",
                        leaf: Leaf.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).leaf)
                    };
                    break;
                case /* base.v1.Rewrite rewrite */ 2:
                    message.type = {
                        oneofKind: "rewrite",
                        rewrite: Rewrite.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).rewrite)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Child, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.Leaf leaf = 1; */
        if (message.type.oneofKind === "leaf")
            Leaf.internalBinaryWrite(message.type.leaf, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Rewrite rewrite = 2; */
        if (message.type.oneofKind === "rewrite")
            Rewrite.internalBinaryWrite(message.type.rewrite, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Child
 */
export const Child = new Child$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Leaf$Type extends MessageType<Leaf> {
    constructor() {
        super("base.v1.Leaf", [
            { no: 1, name: "computed_user_set", kind: "message", oneof: "type", T: () => ComputedUserSet, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "tuple_to_user_set", kind: "message", oneof: "type", T: () => TupleToUserSet, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "computed_attribute", kind: "message", oneof: "type", T: () => ComputedAttribute, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "call", kind: "message", oneof: "type", T: () => Call, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<Leaf>): Leaf {
        const message = { type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Leaf>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Leaf): Leaf {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.ComputedUserSet computed_user_set */ 1:
                    message.type = {
                        oneofKind: "computedUserSet",
                        computedUserSet: ComputedUserSet.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).computedUserSet)
                    };
                    break;
                case /* base.v1.TupleToUserSet tuple_to_user_set */ 2:
                    message.type = {
                        oneofKind: "tupleToUserSet",
                        tupleToUserSet: TupleToUserSet.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).tupleToUserSet)
                    };
                    break;
                case /* base.v1.ComputedAttribute computed_attribute */ 3:
                    message.type = {
                        oneofKind: "computedAttribute",
                        computedAttribute: ComputedAttribute.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).computedAttribute)
                    };
                    break;
                case /* base.v1.Call call */ 4:
                    message.type = {
                        oneofKind: "call",
                        call: Call.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).call)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Leaf, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.ComputedUserSet computed_user_set = 1; */
        if (message.type.oneofKind === "computedUserSet")
            ComputedUserSet.internalBinaryWrite(message.type.computedUserSet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.TupleToUserSet tuple_to_user_set = 2; */
        if (message.type.oneofKind === "tupleToUserSet")
            TupleToUserSet.internalBinaryWrite(message.type.tupleToUserSet, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.ComputedAttribute computed_attribute = 3; */
        if (message.type.oneofKind === "computedAttribute")
            ComputedAttribute.internalBinaryWrite(message.type.computedAttribute, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Call call = 4; */
        if (message.type.oneofKind === "call")
            Call.internalBinaryWrite(message.type.call, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Leaf
 */
export const Leaf = new Leaf$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rewrite$Type extends MessageType<Rewrite> {
    constructor() {
        super("base.v1.Rewrite", [
            { no: 1, name: "rewrite_operation", kind: "enum", T: () => ["base.v1.Rewrite.Operation", Rewrite_Operation, "OPERATION_"] },
            { no: 2, name: "children", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Child }
        ]);
    }
    create(value?: PartialMessage<Rewrite>): Rewrite {
        const message = { rewriteOperation: 0, children: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Rewrite>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rewrite): Rewrite {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.Rewrite.Operation rewrite_operation */ 1:
                    message.rewriteOperation = reader.int32();
                    break;
                case /* repeated base.v1.Child children */ 2:
                    message.children.push(Child.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rewrite, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.Rewrite.Operation rewrite_operation = 1; */
        if (message.rewriteOperation !== 0)
            writer.tag(1, WireType.Varint).int32(message.rewriteOperation);
        /* repeated base.v1.Child children = 2; */
        for (let i = 0; i < message.children.length; i++)
            Child.internalBinaryWrite(message.children[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Rewrite
 */
export const Rewrite = new Rewrite$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaDefinition$Type extends MessageType<SchemaDefinition> {
    constructor() {
        super("base.v1.SchemaDefinition", [
            { no: 1, name: "entity_definitions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => EntityDefinition } },
            { no: 2, name: "rule_definitions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => RuleDefinition } },
            { no: 3, name: "references", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "enum", T: () => ["base.v1.SchemaDefinition.Reference", SchemaDefinition_Reference, "REFERENCE_"] } }
        ]);
    }
    create(value?: PartialMessage<SchemaDefinition>): SchemaDefinition {
        const message = { entityDefinitions: {}, ruleDefinitions: {}, references: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaDefinition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaDefinition): SchemaDefinition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, base.v1.EntityDefinition> entity_definitions */ 1:
                    this.binaryReadMap1(message.entityDefinitions, reader, options);
                    break;
                case /* map<string, base.v1.RuleDefinition> rule_definitions */ 2:
                    this.binaryReadMap2(message.ruleDefinitions, reader, options);
                    break;
                case /* map<string, base.v1.SchemaDefinition.Reference> references */ 3:
                    this.binaryReadMap3(message.references, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: SchemaDefinition["entityDefinitions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SchemaDefinition["entityDefinitions"] | undefined, val: SchemaDefinition["entityDefinitions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = EntityDefinition.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.SchemaDefinition.entity_definitions");
            }
        }
        map[key ?? ""] = val ?? EntityDefinition.create();
    }
    private binaryReadMap2(map: SchemaDefinition["ruleDefinitions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SchemaDefinition["ruleDefinitions"] | undefined, val: SchemaDefinition["ruleDefinitions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = RuleDefinition.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.SchemaDefinition.rule_definitions");
            }
        }
        map[key ?? ""] = val ?? RuleDefinition.create();
    }
    private binaryReadMap3(map: SchemaDefinition["references"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SchemaDefinition["references"] | undefined, val: SchemaDefinition["references"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.SchemaDefinition.references");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: SchemaDefinition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, base.v1.EntityDefinition> entity_definitions = 1; */
        for (let k of Object.keys(message.entityDefinitions)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            EntityDefinition.internalBinaryWrite(message.entityDefinitions[k], writer, options);
            writer.join().join();
        }
        /* map<string, base.v1.RuleDefinition> rule_definitions = 2; */
        for (let k of Object.keys(message.ruleDefinitions)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            RuleDefinition.internalBinaryWrite(message.ruleDefinitions[k], writer, options);
            writer.join().join();
        }
        /* map<string, base.v1.SchemaDefinition.Reference> references = 3; */
        for (let k of Object.keys(message.references))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.references[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaDefinition
 */
export const SchemaDefinition = new SchemaDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityDefinition$Type extends MessageType<EntityDefinition> {
    constructor() {
        super("base.v1.EntityDefinition", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } },
            { no: 2, name: "relations", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => RelationDefinition } },
            { no: 3, name: "permissions", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => PermissionDefinition } },
            { no: 4, name: "attributes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => AttributeDefinition } },
            { no: 5, name: "references", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "enum", T: () => ["base.v1.EntityDefinition.Reference", EntityDefinition_Reference, "REFERENCE_"] } }
        ]);
    }
    create(value?: PartialMessage<EntityDefinition>): EntityDefinition {
        const message = { name: "", relations: {}, permissions: {}, attributes: {}, references: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityDefinition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityDefinition): EntityDefinition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, base.v1.RelationDefinition> relations */ 2:
                    this.binaryReadMap2(message.relations, reader, options);
                    break;
                case /* map<string, base.v1.PermissionDefinition> permissions */ 3:
                    this.binaryReadMap3(message.permissions, reader, options);
                    break;
                case /* map<string, base.v1.AttributeDefinition> attributes */ 4:
                    this.binaryReadMap4(message.attributes, reader, options);
                    break;
                case /* map<string, base.v1.EntityDefinition.Reference> references */ 5:
                    this.binaryReadMap5(message.references, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: EntityDefinition["relations"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EntityDefinition["relations"] | undefined, val: EntityDefinition["relations"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = RelationDefinition.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.EntityDefinition.relations");
            }
        }
        map[key ?? ""] = val ?? RelationDefinition.create();
    }
    private binaryReadMap3(map: EntityDefinition["permissions"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EntityDefinition["permissions"] | undefined, val: EntityDefinition["permissions"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = PermissionDefinition.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.EntityDefinition.permissions");
            }
        }
        map[key ?? ""] = val ?? PermissionDefinition.create();
    }
    private binaryReadMap4(map: EntityDefinition["attributes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EntityDefinition["attributes"] | undefined, val: EntityDefinition["attributes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = AttributeDefinition.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.EntityDefinition.attributes");
            }
        }
        map[key ?? ""] = val ?? AttributeDefinition.create();
    }
    private binaryReadMap5(map: EntityDefinition["references"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EntityDefinition["references"] | undefined, val: EntityDefinition["references"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.EntityDefinition.references");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: EntityDefinition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, base.v1.RelationDefinition> relations = 2; */
        for (let k of Object.keys(message.relations)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            RelationDefinition.internalBinaryWrite(message.relations[k], writer, options);
            writer.join().join();
        }
        /* map<string, base.v1.PermissionDefinition> permissions = 3; */
        for (let k of Object.keys(message.permissions)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            PermissionDefinition.internalBinaryWrite(message.permissions[k], writer, options);
            writer.join().join();
        }
        /* map<string, base.v1.AttributeDefinition> attributes = 4; */
        for (let k of Object.keys(message.attributes)) {
            writer.tag(4, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            AttributeDefinition.internalBinaryWrite(message.attributes[k], writer, options);
            writer.join().join();
        }
        /* map<string, base.v1.EntityDefinition.Reference> references = 5; */
        for (let k of Object.keys(message.references))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.references[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.EntityDefinition
 */
export const EntityDefinition = new EntityDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RuleDefinition$Type extends MessageType<RuleDefinition> {
    constructor() {
        super("base.v1.RuleDefinition", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } },
            { no: 2, name: "arguments", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "enum", T: () => ["base.v1.AttributeType", AttributeType, "ATTRIBUTE_TYPE_"] } },
            { no: 3, name: "expression", kind: "message", T: () => CheckedExpr }
        ]);
    }
    create(value?: PartialMessage<RuleDefinition>): RuleDefinition {
        const message = { name: "", arguments: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RuleDefinition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RuleDefinition): RuleDefinition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, base.v1.AttributeType> arguments */ 2:
                    this.binaryReadMap2(message.arguments, reader, options);
                    break;
                case /* google.api.expr.v1alpha1.CheckedExpr expression */ 3:
                    message.expression = CheckedExpr.internalBinaryRead(reader, reader.uint32(), options, message.expression);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: RuleDefinition["arguments"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof RuleDefinition["arguments"] | undefined, val: RuleDefinition["arguments"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.RuleDefinition.arguments");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: RuleDefinition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, base.v1.AttributeType> arguments = 2; */
        for (let k of Object.keys(message.arguments))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.arguments[k]).join();
        /* google.api.expr.v1alpha1.CheckedExpr expression = 3; */
        if (message.expression)
            CheckedExpr.internalBinaryWrite(message.expression, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RuleDefinition
 */
export const RuleDefinition = new RuleDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeDefinition$Type extends MessageType<AttributeDefinition> {
    constructor() {
        super("base.v1.AttributeDefinition", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } },
            { no: 2, name: "type", kind: "enum", T: () => ["base.v1.AttributeType", AttributeType, "ATTRIBUTE_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<AttributeDefinition>): AttributeDefinition {
        const message = { name: "", type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttributeDefinition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeDefinition): AttributeDefinition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* base.v1.AttributeType type */ 2:
                    message.type = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeDefinition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* base.v1.AttributeType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.AttributeDefinition
 */
export const AttributeDefinition = new AttributeDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationDefinition$Type extends MessageType<RelationDefinition> {
    constructor() {
        super("base.v1.RelationDefinition", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } },
            { no: 2, name: "relation_references", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => RelationReference }
        ]);
    }
    create(value?: PartialMessage<RelationDefinition>): RelationDefinition {
        const message = { name: "", relationReferences: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationDefinition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationDefinition): RelationDefinition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated base.v1.RelationReference relation_references */ 2:
                    message.relationReferences.push(RelationReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationDefinition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated base.v1.RelationReference relation_references = 2; */
        for (let i = 0; i < message.relationReferences.length; i++)
            RelationReference.internalBinaryWrite(message.relationReferences[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RelationDefinition
 */
export const RelationDefinition = new RelationDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionDefinition$Type extends MessageType<PermissionDefinition> {
    constructor() {
        super("base.v1.PermissionDefinition", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } },
            { no: 2, name: "child", kind: "message", T: () => Child }
        ]);
    }
    create(value?: PartialMessage<PermissionDefinition>): PermissionDefinition {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionDefinition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionDefinition): PermissionDefinition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* base.v1.Child child */ 2:
                    message.child = Child.internalBinaryRead(reader, reader.uint32(), options, message.child);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionDefinition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* base.v1.Child child = 2; */
        if (message.child)
            Child.internalBinaryWrite(message.child, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionDefinition
 */
export const PermissionDefinition = new PermissionDefinition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationReference$Type extends MessageType<RelationReference> {
    constructor() {
        super("base.v1.RelationReference", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$", ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<RelationReference>): RelationReference {
        const message = { type: "", relation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationReference): RelationReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RelationReference
 */
export const RelationReference = new RelationReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Entrance$Type extends MessageType<Entrance> {
    constructor() {
        super("base.v1.Entrance", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } }
        ]);
    }
    create(value?: PartialMessage<Entrance>): Entrance {
        const message = { type: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Entrance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entrance): Entrance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Entrance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Entrance
 */
export const Entrance = new Entrance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Argument$Type extends MessageType<Argument> {
    constructor() {
        super("base.v1.Argument", [
            { no: 1, name: "computed_attribute", kind: "message", oneof: "type", T: () => ComputedAttribute }
        ]);
    }
    create(value?: PartialMessage<Argument>): Argument {
        const message = { type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Argument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Argument): Argument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.ComputedAttribute computed_attribute */ 1:
                    message.type = {
                        oneofKind: "computedAttribute",
                        computedAttribute: ComputedAttribute.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).computedAttribute)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Argument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.ComputedAttribute computed_attribute = 1; */
        if (message.type.oneofKind === "computedAttribute")
            ComputedAttribute.internalBinaryWrite(message.type.computedAttribute, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Argument
 */
export const Argument = new Argument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Call$Type extends MessageType<Call> {
    constructor() {
        super("base.v1.Call", [
            { no: 1, name: "rule_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "arguments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Argument }
        ]);
    }
    create(value?: PartialMessage<Call>): Call {
        const message = { ruleName: "", arguments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Call>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Call): Call {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string rule_name */ 1:
                    message.ruleName = reader.string();
                    break;
                case /* repeated base.v1.Argument arguments */ 2:
                    message.arguments.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Call, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string rule_name = 1; */
        if (message.ruleName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ruleName);
        /* repeated base.v1.Argument arguments = 2; */
        for (let i = 0; i < message.arguments.length; i++)
            Argument.internalBinaryWrite(message.arguments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Call
 */
export const Call = new Call$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComputedAttribute$Type extends MessageType<ComputedAttribute> {
    constructor() {
        super("base.v1.ComputedAttribute", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } }
        ]);
    }
    create(value?: PartialMessage<ComputedAttribute>): ComputedAttribute {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ComputedAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ComputedAttribute): ComputedAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ComputedAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.ComputedAttribute
 */
export const ComputedAttribute = new ComputedAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ComputedUserSet$Type extends MessageType<ComputedUserSet> {
    constructor() {
        super("base.v1.ComputedUserSet", [
            { no: 1, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } }
        ]);
    }
    create(value?: PartialMessage<ComputedUserSet>): ComputedUserSet {
        const message = { relation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ComputedUserSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ComputedUserSet): ComputedUserSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string relation */ 1:
                    message.relation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ComputedUserSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string relation = 1; */
        if (message.relation !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.relation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.ComputedUserSet
 */
export const ComputedUserSet = new ComputedUserSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TupleToUserSet$Type extends MessageType<TupleToUserSet> {
    constructor() {
        super("base.v1.TupleToUserSet", [
            { no: 1, name: "tupleSet", kind: "message", T: () => TupleSet },
            { no: 2, name: "computed", kind: "message", T: () => ComputedUserSet }
        ]);
    }
    create(value?: PartialMessage<TupleToUserSet>): TupleToUserSet {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TupleToUserSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TupleToUserSet): TupleToUserSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.TupleSet tupleSet */ 1:
                    message.tupleSet = TupleSet.internalBinaryRead(reader, reader.uint32(), options, message.tupleSet);
                    break;
                case /* base.v1.ComputedUserSet computed */ 2:
                    message.computed = ComputedUserSet.internalBinaryRead(reader, reader.uint32(), options, message.computed);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TupleToUserSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.TupleSet tupleSet = 1; */
        if (message.tupleSet)
            TupleSet.internalBinaryWrite(message.tupleSet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.ComputedUserSet computed = 2; */
        if (message.computed)
            ComputedUserSet.internalBinaryWrite(message.computed, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.TupleToUserSet
 */
export const TupleToUserSet = new TupleToUserSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TupleSet$Type extends MessageType<TupleSet> {
    constructor() {
        super("base.v1.TupleSet", [
            { no: 1, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } }
        ]);
    }
    create(value?: PartialMessage<TupleSet>): TupleSet {
        const message = { relation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TupleSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TupleSet): TupleSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string relation */ 1:
                    message.relation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TupleSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string relation = 1; */
        if (message.relation !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.relation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.TupleSet
 */
export const TupleSet = new TupleSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tuple$Type extends MessageType<Tuple> {
    constructor() {
        super("base.v1.Tuple", [
            { no: 1, name: "entity", kind: "message", T: () => Entity, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } },
            { no: 3, name: "subject", kind: "message", T: () => Subject, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<Tuple>): Tuple {
        const message = { relation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tuple>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tuple): Tuple {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.Entity entity */ 1:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                case /* base.v1.Subject subject */ 3:
                    message.subject = Subject.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tuple, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.Entity entity = 1; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        /* base.v1.Subject subject = 3; */
        if (message.subject)
            Subject.internalBinaryWrite(message.subject, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Tuple
 */
export const Tuple = new Tuple$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Attribute$Type extends MessageType<Attribute> {
    constructor() {
        super("base.v1.Attribute", [
            { no: 1, name: "entity", kind: "message", T: () => Entity, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<Attribute>): Attribute {
        const message = { attribute: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Attribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Attribute): Attribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.Entity entity */ 1:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* string attribute */ 2:
                    message.attribute = reader.string();
                    break;
                case /* google.protobuf.Any value */ 3:
                    message.value = Any.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Attribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.Entity entity = 1; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string attribute = 2; */
        if (message.attribute !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.attribute);
        /* google.protobuf.Any value = 3; */
        if (message.value)
            Any.internalBinaryWrite(message.value, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Attribute
 */
export const Attribute = new Attribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tuples$Type extends MessageType<Tuples> {
    constructor() {
        super("base.v1.Tuples", [
            { no: 1, name: "tuples", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tuple }
        ]);
    }
    create(value?: PartialMessage<Tuples>): Tuples {
        const message = { tuples: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tuples>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tuples): Tuples {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated base.v1.Tuple tuples */ 1:
                    message.tuples.push(Tuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tuples, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated base.v1.Tuple tuples = 1; */
        for (let i = 0; i < message.tuples.length; i++)
            Tuple.internalBinaryWrite(message.tuples[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Tuples
 */
export const Tuples = new Tuples$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Attributes$Type extends MessageType<Attributes> {
    constructor() {
        super("base.v1.Attributes", [
            { no: 1, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Attribute }
        ]);
    }
    create(value?: PartialMessage<Attributes>): Attributes {
        const message = { attributes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Attributes>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Attributes): Attributes {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated base.v1.Attribute attributes */ 1:
                    message.attributes.push(Attribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Attributes, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated base.v1.Attribute attributes = 1; */
        for (let i = 0; i < message.attributes.length; i++)
            Attribute.internalBinaryWrite(message.attributes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Attributes
 */
export const Attributes = new Attributes$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Entity$Type extends MessageType<Entity> {
    constructor() {
        super("base.v1.Entity", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$" } } } }
        ]);
    }
    create(value?: PartialMessage<Entity>): Entity {
        const message = { type: "", id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Entity>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Entity): Entity {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Entity, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Entity
 */
export const Entity = new Entity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityAndRelation$Type extends MessageType<EntityAndRelation> {
    constructor() {
        super("base.v1.EntityAndRelation", [
            { no: 1, name: "entity", kind: "message", T: () => Entity, options: { "validate.rules": { message: { required: true } } } },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } }
        ]);
    }
    create(value?: PartialMessage<EntityAndRelation>): EntityAndRelation {
        const message = { relation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityAndRelation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityAndRelation): EntityAndRelation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.Entity entity */ 1:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityAndRelation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.Entity entity = 1; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.EntityAndRelation
 */
export const EntityAndRelation = new EntityAndRelation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Subject$Type extends MessageType<Subject> {
    constructor() {
        super("base.v1.Subject", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$" } } } },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$" } } } },
            { no: 3, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$", ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<Subject>): Subject {
        const message = { type: "", id: "", relation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Subject>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subject): Subject {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string relation */ 3:
                    message.relation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subject, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string relation = 3; */
        if (message.relation !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.relation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Subject
 */
export const Subject = new Subject$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeFilter$Type extends MessageType<AttributeFilter> {
    constructor() {
        super("base.v1.AttributeFilter", [
            { no: 1, name: "entity", kind: "message", T: () => EntityFilter },
            { no: 2, name: "attributes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttributeFilter>): AttributeFilter {
        const message = { attributes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttributeFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeFilter): AttributeFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.EntityFilter entity */ 1:
                    message.entity = EntityFilter.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* repeated string attributes */ 2:
                    message.attributes.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.EntityFilter entity = 1; */
        if (message.entity)
            EntityFilter.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string attributes = 2; */
        for (let i = 0; i < message.attributes.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.attributes[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.AttributeFilter
 */
export const AttributeFilter = new AttributeFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TupleFilter$Type extends MessageType<TupleFilter> {
    constructor() {
        super("base.v1.TupleFilter", [
            { no: 1, name: "entity", kind: "message", T: () => EntityFilter },
            { no: 2, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$", ignoreEmpty: true } } } },
            { no: 3, name: "subject", kind: "message", T: () => SubjectFilter }
        ]);
    }
    create(value?: PartialMessage<TupleFilter>): TupleFilter {
        const message = { relation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TupleFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TupleFilter): TupleFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.EntityFilter entity */ 1:
                    message.entity = EntityFilter.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* string relation */ 2:
                    message.relation = reader.string();
                    break;
                case /* base.v1.SubjectFilter subject */ 3:
                    message.subject = SubjectFilter.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TupleFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.EntityFilter entity = 1; */
        if (message.entity)
            EntityFilter.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string relation = 2; */
        if (message.relation !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relation);
        /* base.v1.SubjectFilter subject = 3; */
        if (message.subject)
            SubjectFilter.internalBinaryWrite(message.subject, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.TupleFilter
 */
export const TupleFilter = new TupleFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EntityFilter$Type extends MessageType<EntityFilter> {
    constructor() {
        super("base.v1.EntityFilter", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EntityFilter>): EntityFilter {
        const message = { type: "", ids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EntityFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EntityFilter): EntityFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated string ids */ 2:
                    message.ids.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EntityFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* repeated string ids = 2; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.EntityFilter
 */
export const EntityFilter = new EntityFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubjectFilter$Type extends MessageType<SubjectFilter> {
    constructor() {
        super("base.v1.SubjectFilter", [
            { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "relation", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$", ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<SubjectFilter>): SubjectFilter {
        const message = { type: "", ids: [], relation: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubjectFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubjectFilter): SubjectFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string type */ 1:
                    message.type = reader.string();
                    break;
                case /* repeated string ids */ 2:
                    message.ids.push(reader.string());
                    break;
                case /* string relation */ 3:
                    message.relation = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubjectFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string type = 1; */
        if (message.type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* repeated string ids = 2; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.ids[i]);
        /* string relation = 3; */
        if (message.relation !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.relation);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SubjectFilter
 */
export const SubjectFilter = new SubjectFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandTreeNode$Type extends MessageType<ExpandTreeNode> {
    constructor() {
        super("base.v1.ExpandTreeNode", [
            { no: 1, name: "operation", kind: "enum", T: () => ["base.v1.ExpandTreeNode.Operation", ExpandTreeNode_Operation, "OPERATION_"] },
            { no: 2, name: "children", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expand }
        ]);
    }
    create(value?: PartialMessage<ExpandTreeNode>): ExpandTreeNode {
        const message = { operation: 0, children: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExpandTreeNode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpandTreeNode): ExpandTreeNode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.ExpandTreeNode.Operation operation */ 1:
                    message.operation = reader.int32();
                    break;
                case /* repeated base.v1.Expand children */ 2:
                    message.children.push(Expand.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpandTreeNode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.ExpandTreeNode.Operation operation = 1; */
        if (message.operation !== 0)
            writer.tag(1, WireType.Varint).int32(message.operation);
        /* repeated base.v1.Expand children = 2; */
        for (let i = 0; i < message.children.length; i++)
            Expand.internalBinaryWrite(message.children[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.ExpandTreeNode
 */
export const ExpandTreeNode = new ExpandTreeNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expand$Type extends MessageType<Expand> {
    constructor() {
        super("base.v1.Expand", [
            { no: 1, name: "entity", kind: "message", T: () => Entity },
            { no: 2, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "arguments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Argument },
            { no: 4, name: "expand", kind: "message", oneof: "node", T: () => ExpandTreeNode },
            { no: 5, name: "leaf", kind: "message", oneof: "node", T: () => ExpandLeaf }
        ]);
    }
    create(value?: PartialMessage<Expand>): Expand {
        const message = { permission: "", arguments: [], node: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expand): Expand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.Entity entity */ 1:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* string permission */ 2:
                    message.permission = reader.string();
                    break;
                case /* repeated base.v1.Argument arguments */ 3:
                    message.arguments.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* base.v1.ExpandTreeNode expand */ 4:
                    message.node = {
                        oneofKind: "expand",
                        expand: ExpandTreeNode.internalBinaryRead(reader, reader.uint32(), options, (message.node as any).expand)
                    };
                    break;
                case /* base.v1.ExpandLeaf leaf */ 5:
                    message.node = {
                        oneofKind: "leaf",
                        leaf: ExpandLeaf.internalBinaryRead(reader, reader.uint32(), options, (message.node as any).leaf)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.Entity entity = 1; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 2; */
        if (message.permission !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.permission);
        /* repeated base.v1.Argument arguments = 3; */
        for (let i = 0; i < message.arguments.length; i++)
            Argument.internalBinaryWrite(message.arguments[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.ExpandTreeNode expand = 4; */
        if (message.node.oneofKind === "expand")
            ExpandTreeNode.internalBinaryWrite(message.node.expand, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.ExpandLeaf leaf = 5; */
        if (message.node.oneofKind === "leaf")
            ExpandLeaf.internalBinaryWrite(message.node.leaf, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Expand
 */
export const Expand = new Expand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExpandLeaf$Type extends MessageType<ExpandLeaf> {
    constructor() {
        super("base.v1.ExpandLeaf", [
            { no: 1, name: "subjects", kind: "message", oneof: "type", T: () => Subjects },
            { no: 2, name: "values", kind: "message", oneof: "type", T: () => Values },
            { no: 3, name: "value", kind: "message", oneof: "type", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ExpandLeaf>): ExpandLeaf {
        const message = { type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExpandLeaf>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExpandLeaf): ExpandLeaf {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.Subjects subjects */ 1:
                    message.type = {
                        oneofKind: "subjects",
                        subjects: Subjects.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).subjects)
                    };
                    break;
                case /* base.v1.Values values */ 2:
                    message.type = {
                        oneofKind: "values",
                        values: Values.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).values)
                    };
                    break;
                case /* google.protobuf.Any value */ 3:
                    message.type = {
                        oneofKind: "value",
                        value: Any.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).value)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExpandLeaf, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.Subjects subjects = 1; */
        if (message.type.oneofKind === "subjects")
            Subjects.internalBinaryWrite(message.type.subjects, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Values values = 2; */
        if (message.type.oneofKind === "values")
            Values.internalBinaryWrite(message.type.values, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any value = 3; */
        if (message.type.oneofKind === "value")
            Any.internalBinaryWrite(message.type.value, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.ExpandLeaf
 */
export const ExpandLeaf = new ExpandLeaf$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Values$Type extends MessageType<Values> {
    constructor() {
        super("base.v1.Values", [
            { no: 1, name: "values", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Any } }
        ]);
    }
    create(value?: PartialMessage<Values>): Values {
        const message = { values: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Values>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Values): Values {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, google.protobuf.Any> values */ 1:
                    this.binaryReadMap1(message.values, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: Values["values"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Values["values"] | undefined, val: Values["values"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Any.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.Values.values");
            }
        }
        map[key ?? ""] = val ?? Any.create();
    }
    internalBinaryWrite(message: Values, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, google.protobuf.Any> values = 1; */
        for (let k of Object.keys(message.values)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Any.internalBinaryWrite(message.values[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Values
 */
export const Values = new Values$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Subjects$Type extends MessageType<Subjects> {
    constructor() {
        super("base.v1.Subjects", [
            { no: 1, name: "subjects", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Subject }
        ]);
    }
    create(value?: PartialMessage<Subjects>): Subjects {
        const message = { subjects: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Subjects>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subjects): Subjects {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated base.v1.Subject subjects */ 1:
                    message.subjects.push(Subject.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subjects, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated base.v1.Subject subjects = 1; */
        for (let i = 0; i < message.subjects.length; i++)
            Subject.internalBinaryWrite(message.subjects[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Subjects
 */
export const Subjects = new Subjects$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tenant$Type extends MessageType<Tenant> {
    constructor() {
        super("base.v1.Tenant", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "created_at", kind: "message", jsonName: "created_at", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Tenant>): Tenant {
        const message = { id: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tenant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tenant): Tenant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at = 3 [json_name = "created_at"];*/ 3:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tenant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp created_at = 3 [json_name = "created_at"]; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Tenant
 */
export const Tenant = new Tenant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataChanges$Type extends MessageType<DataChanges> {
    constructor() {
        super("base.v1.DataChanges", [
            { no: 1, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "data_changes", kind: "message", jsonName: "data_changes", repeat: 1 /*RepeatType.PACKED*/, T: () => DataChange }
        ]);
    }
    create(value?: PartialMessage<DataChanges>): DataChanges {
        const message = { snapToken: "", dataChanges: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DataChanges>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataChanges): DataChanges {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string snap_token = 1 [json_name = "snap_token"];*/ 1:
                    message.snapToken = reader.string();
                    break;
                case /* repeated base.v1.DataChange data_changes = 2 [json_name = "data_changes"];*/ 2:
                    message.dataChanges.push(DataChange.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataChanges, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string snap_token = 1 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snapToken);
        /* repeated base.v1.DataChange data_changes = 2 [json_name = "data_changes"]; */
        for (let i = 0; i < message.dataChanges.length; i++)
            DataChange.internalBinaryWrite(message.dataChanges[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.DataChanges
 */
export const DataChanges = new DataChanges$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataChange$Type extends MessageType<DataChange> {
    constructor() {
        super("base.v1.DataChange", [
            { no: 1, name: "operation", kind: "enum", T: () => ["base.v1.DataChange.Operation", DataChange_Operation, "OPERATION_"] },
            { no: 2, name: "tuple", kind: "message", oneof: "type", T: () => Tuple },
            { no: 3, name: "attribute", kind: "message", oneof: "type", T: () => Attribute }
        ]);
    }
    create(value?: PartialMessage<DataChange>): DataChange {
        const message = { operation: 0, type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DataChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataChange): DataChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.DataChange.Operation operation */ 1:
                    message.operation = reader.int32();
                    break;
                case /* base.v1.Tuple tuple */ 2:
                    message.type = {
                        oneofKind: "tuple",
                        tuple: Tuple.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).tuple)
                    };
                    break;
                case /* base.v1.Attribute attribute */ 3:
                    message.type = {
                        oneofKind: "attribute",
                        attribute: Attribute.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).attribute)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.DataChange.Operation operation = 1; */
        if (message.operation !== 0)
            writer.tag(1, WireType.Varint).int32(message.operation);
        /* base.v1.Tuple tuple = 2; */
        if (message.type.oneofKind === "tuple")
            Tuple.internalBinaryWrite(message.type.tuple, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Attribute attribute = 3; */
        if (message.type.oneofKind === "attribute")
            Attribute.internalBinaryWrite(message.type.attribute, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.DataChange
 */
export const DataChange = new DataChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringValue$Type extends MessageType<StringValue> {
    constructor() {
        super("base.v1.StringValue", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StringValue>): StringValue {
        const message = { data: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StringValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StringValue): StringValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StringValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.StringValue
 */
export const StringValue = new StringValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntegerValue$Type extends MessageType<IntegerValue> {
    constructor() {
        super("base.v1.IntegerValue", [
            { no: 1, name: "data", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<IntegerValue>): IntegerValue {
        const message = { data: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IntegerValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IntegerValue): IntegerValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 data */ 1:
                    message.data = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IntegerValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 data = 1; */
        if (message.data !== 0)
            writer.tag(1, WireType.Varint).int32(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.IntegerValue
 */
export const IntegerValue = new IntegerValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoubleValue$Type extends MessageType<DoubleValue> {
    constructor() {
        super("base.v1.DoubleValue", [
            { no: 1, name: "data", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<DoubleValue>): DoubleValue {
        const message = { data: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DoubleValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoubleValue): DoubleValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double data */ 1:
                    message.data = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoubleValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double data = 1; */
        if (message.data !== 0)
            writer.tag(1, WireType.Bit64).double(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.DoubleValue
 */
export const DoubleValue = new DoubleValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BooleanValue$Type extends MessageType<BooleanValue> {
    constructor() {
        super("base.v1.BooleanValue", [
            { no: 1, name: "data", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BooleanValue>): BooleanValue {
        const message = { data: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BooleanValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BooleanValue): BooleanValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool data */ 1:
                    message.data = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BooleanValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool data = 1; */
        if (message.data !== false)
            writer.tag(1, WireType.Varint).bool(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.BooleanValue
 */
export const BooleanValue = new BooleanValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StringArrayValue$Type extends MessageType<StringArrayValue> {
    constructor() {
        super("base.v1.StringArrayValue", [
            { no: 1, name: "data", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StringArrayValue>): StringArrayValue {
        const message = { data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StringArrayValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StringArrayValue): StringArrayValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string data */ 1:
                    message.data.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StringArrayValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string data = 1; */
        for (let i = 0; i < message.data.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.data[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.StringArrayValue
 */
export const StringArrayValue = new StringArrayValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IntegerArrayValue$Type extends MessageType<IntegerArrayValue> {
    constructor() {
        super("base.v1.IntegerArrayValue", [
            { no: 1, name: "data", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<IntegerArrayValue>): IntegerArrayValue {
        const message = { data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IntegerArrayValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IntegerArrayValue): IntegerArrayValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 data */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.data.push(reader.int32());
                    else
                        message.data.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IntegerArrayValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 data = 1; */
        if (message.data.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.data.length; i++)
                writer.int32(message.data[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.IntegerArrayValue
 */
export const IntegerArrayValue = new IntegerArrayValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DoubleArrayValue$Type extends MessageType<DoubleArrayValue> {
    constructor() {
        super("base.v1.DoubleArrayValue", [
            { no: 1, name: "data", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<DoubleArrayValue>): DoubleArrayValue {
        const message = { data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DoubleArrayValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DoubleArrayValue): DoubleArrayValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated double data */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.data.push(reader.double());
                    else
                        message.data.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DoubleArrayValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated double data = 1; */
        if (message.data.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.data.length; i++)
                writer.double(message.data[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.DoubleArrayValue
 */
export const DoubleArrayValue = new DoubleArrayValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BooleanArrayValue$Type extends MessageType<BooleanArrayValue> {
    constructor() {
        super("base.v1.BooleanArrayValue", [
            { no: 1, name: "data", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BooleanArrayValue>): BooleanArrayValue {
        const message = { data: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BooleanArrayValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BooleanArrayValue): BooleanArrayValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bool data */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.data.push(reader.bool());
                    else
                        message.data.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BooleanArrayValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bool data = 1; */
        if (message.data.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.data.length; i++)
                writer.bool(message.data[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.BooleanArrayValue
 */
export const BooleanArrayValue = new BooleanArrayValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataBundle$Type extends MessageType<DataBundle> {
    constructor() {
        super("base.v1.DataBundle", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "arguments", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "operations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Operation }
        ]);
    }
    create(value?: PartialMessage<DataBundle>): DataBundle {
        const message = { name: "", arguments: [], operations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DataBundle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataBundle): DataBundle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated string arguments */ 2:
                    message.arguments.push(reader.string());
                    break;
                case /* repeated base.v1.Operation operations */ 3:
                    message.operations.push(Operation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataBundle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated string arguments = 2; */
        for (let i = 0; i < message.arguments.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.arguments[i]);
        /* repeated base.v1.Operation operations = 3; */
        for (let i = 0; i < message.operations.length; i++)
            Operation.internalBinaryWrite(message.operations[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.DataBundle
 */
export const DataBundle = new DataBundle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Operation$Type extends MessageType<Operation> {
    constructor() {
        super("base.v1.Operation", [
            { no: 1, name: "relationships_write", kind: "scalar", jsonName: "relationships_write", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "relationships_delete", kind: "scalar", jsonName: "relationships_delete", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "attributes_write", kind: "scalar", jsonName: "attributes_write", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "attributes_delete", kind: "scalar", jsonName: "attributes_delete", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Operation>): Operation {
        const message = { relationshipsWrite: [], relationshipsDelete: [], attributesWrite: [], attributesDelete: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Operation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Operation): Operation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string relationships_write = 1 [json_name = "relationships_write"];*/ 1:
                    message.relationshipsWrite.push(reader.string());
                    break;
                case /* repeated string relationships_delete = 2 [json_name = "relationships_delete"];*/ 2:
                    message.relationshipsDelete.push(reader.string());
                    break;
                case /* repeated string attributes_write = 3 [json_name = "attributes_write"];*/ 3:
                    message.attributesWrite.push(reader.string());
                    break;
                case /* repeated string attributes_delete = 4 [json_name = "attributes_delete"];*/ 4:
                    message.attributesDelete.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Operation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string relationships_write = 1 [json_name = "relationships_write"]; */
        for (let i = 0; i < message.relationshipsWrite.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.relationshipsWrite[i]);
        /* repeated string relationships_delete = 2 [json_name = "relationships_delete"]; */
        for (let i = 0; i < message.relationshipsDelete.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.relationshipsDelete[i]);
        /* repeated string attributes_write = 3 [json_name = "attributes_write"]; */
        for (let i = 0; i < message.attributesWrite.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.attributesWrite[i]);
        /* repeated string attributes_delete = 4 [json_name = "attributes_delete"]; */
        for (let i = 0; i < message.attributesDelete.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.attributesDelete[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Operation
 */
export const Operation = new Operation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Partials$Type extends MessageType<Partials> {
    constructor() {
        super("base.v1.Partials", [
            { no: 1, name: "write", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "delete", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "update", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Partials>): Partials {
        const message = { write: [], delete: [], update: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Partials>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Partials): Partials {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string write */ 1:
                    message.write.push(reader.string());
                    break;
                case /* repeated string delete */ 2:
                    message.delete.push(reader.string());
                    break;
                case /* repeated string update */ 3:
                    message.update.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Partials, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string write = 1; */
        for (let i = 0; i < message.write.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.write[i]);
        /* repeated string delete = 2; */
        for (let i = 0; i < message.delete.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.delete[i]);
        /* repeated string update = 3; */
        for (let i = 0; i < message.update.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.update[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.Partials
 */
export const Partials = new Partials$Type();
