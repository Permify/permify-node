// @generated by protobuf-ts 2.9.1 with parameter long_type_string,client_grpc1,generate_dependencies
// @generated from protobuf file "base/v1/service.proto" (package "base.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Tenant } from "./base";
import { DataBundle } from "./base";
import { AttributeFilter } from "./base";
import { TupleFilter } from "./base";
import { Attribute } from "./base";
import { Tuple } from "./base";
import { SchemaDefinition } from "./base";
import { Partials } from "./base";
import { DataChanges } from "./base";
import { RelationReference } from "./base";
import { Entrance } from "./base";
import { StringArrayValue } from "./base";
import { Expand } from "./base";
import { CheckResult } from "./base";
import { Argument } from "./base";
import { Context } from "./base";
import { Subject } from "./base";
import { Entity } from "./base";
// CHECK

/**
 * PermissionCheckRequest is the request message for the Check method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionCheckRequest
 */
export interface PermissionCheckRequest {
    /**
     * Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * Metadata associated with this request, required.
     *
     * @generated from protobuf field: base.v1.PermissionCheckRequestMetadata metadata = 2;
     */
    metadata?: PermissionCheckRequestMetadata;
    /**
     * Entity on which the permission needs to be checked, required.
     *
     * @generated from protobuf field: base.v1.Entity entity = 3;
     */
    entity?: Entity;
    /**
     * Name of the permission or relation, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
     *
     * @generated from protobuf field: string permission = 4;
     */
    permission: string;
    /**
     * Subject for which the permission needs to be checked, required.
     *
     * @generated from protobuf field: base.v1.Subject subject = 5;
     */
    subject?: Subject;
    /**
     * Context associated with this request.
     *
     * @generated from protobuf field: base.v1.Context context = 6;
     */
    context?: Context;
    /**
     * Additional arguments associated with this request.
     *
     * @generated from protobuf field: repeated base.v1.Argument arguments = 7;
     */
    arguments: Argument[];
}
/**
 * PermissionCheckRequestMetadata metadata for the PermissionCheckRequest.
 *
 * @generated from protobuf message base.v1.PermissionCheckRequestMetadata
 */
export interface PermissionCheckRequestMetadata {
    /**
     * Version of the schema.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
    /**
     * Token associated with the snap.
     *
     * @generated from protobuf field: string snap_token = 2 [json_name = "snap_token"];
     */
    snapToken: string;
    /**
     * Depth of the check, must be greater than or equal to 3.
     *
     * @generated from protobuf field: int32 depth = 3;
     */
    depth: number;
}
/**
 * PermissionCheckResponse is the response message for the Check method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionCheckResponse
 */
export interface PermissionCheckResponse {
    /**
     * Result of the permission check.
     *
     * @generated from protobuf field: base.v1.CheckResult can = 1;
     */
    can: CheckResult;
    /**
     * Metadata associated with this response.
     *
     * @generated from protobuf field: base.v1.PermissionCheckResponseMetadata metadata = 2;
     */
    metadata?: PermissionCheckResponseMetadata;
}
/**
 * PermissionCheckResponseMetadata metadata for the PermissionCheckResponse.
 *
 * @generated from protobuf message base.v1.PermissionCheckResponseMetadata
 */
export interface PermissionCheckResponseMetadata {
    /**
     * The count of the checks performed.
     *
     * @generated from protobuf field: int32 check_count = 1 [json_name = "check_count"];
     */
    checkCount: number;
}
// EXPAND

/**
 * PermissionExpandRequest is the request message for the Expand method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionExpandRequest
 */
export interface PermissionExpandRequest {
    /**
     * Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * Metadata associated with this request, required.
     *
     * @generated from protobuf field: base.v1.PermissionExpandRequestMetadata metadata = 2;
     */
    metadata?: PermissionExpandRequestMetadata;
    /**
     * Entity on which the permission needs to be expanded, required.
     *
     * @generated from protobuf field: base.v1.Entity entity = 3;
     */
    entity?: Entity;
    /**
     * Name of the permission to be expanded, not required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
     *
     * @generated from protobuf field: string permission = 4;
     */
    permission: string;
    /**
     * Context associated with this request.
     *
     * @generated from protobuf field: base.v1.Context context = 5;
     */
    context?: Context;
    /**
     * Additional arguments associated with this request.
     *
     * @generated from protobuf field: repeated base.v1.Argument arguments = 6;
     */
    arguments: Argument[];
}
/**
 * PermissionExpandRequestMetadata metadata for the PermissionExpandRequest.
 *
 * @generated from protobuf message base.v1.PermissionExpandRequestMetadata
 */
export interface PermissionExpandRequestMetadata {
    /**
     * Version of the schema.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
    /**
     * Token associated with the snap.
     *
     * @generated from protobuf field: string snap_token = 2 [json_name = "snap_token"];
     */
    snapToken: string;
}
/**
 * PermissionExpandResponse is the response message for the Expand method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionExpandResponse
 */
export interface PermissionExpandResponse {
    /**
     * Expansion tree.
     *
     * @generated from protobuf field: base.v1.Expand tree = 1;
     */
    tree?: Expand;
}
// LOOKUP ENTITY

/**
 * PermissionLookupEntityRequest is the request message for the LookupEntity method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionLookupEntityRequest
 */
export interface PermissionLookupEntityRequest {
    /**
     * Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * Metadata associated with this request, required.
     *
     * @generated from protobuf field: base.v1.PermissionLookupEntityRequestMetadata metadata = 2;
     */
    metadata?: PermissionLookupEntityRequestMetadata;
    /**
     * Type of the entity to lookup, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
     *
     * @generated from protobuf field: string entity_type = 3 [json_name = "entity_type"];
     */
    entityType: string;
    /**
     * Name of the permission to check, required, must start with a letter and can include alphanumeric and underscore, max 64 bytes.
     *
     * @generated from protobuf field: string permission = 4;
     */
    permission: string;
    /**
     * Subject for which to check the permission, required.
     *
     * @generated from protobuf field: base.v1.Subject subject = 5;
     */
    subject?: Subject;
    /**
     * Context associated with this request.
     *
     * @generated from protobuf field: base.v1.Context context = 6;
     */
    context?: Context;
    /**
     * Scope: A map that associates entity types with lists of identifiers. Each entry
     * helps filter requests by specifying which entities are relevant to the operation.
     *
     * @generated from protobuf field: map<string, base.v1.StringArrayValue> scope = 7;
     */
    scope: {
        [key: string]: StringArrayValue;
    };
    /**
     * page_size is the number of entities to be returned in the response.
     * The value should be between 1 and 100.
     *
     * @generated from protobuf field: uint32 page_size = 8 [json_name = "page_size"];
     */
    pageSize: number;
    /**
     * continuous_token is an optional parameter used for pagination.
     * It should be the value received in the previous response.
     *
     * @generated from protobuf field: string continuous_token = 9 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
/**
 * PermissionLookupEntityRequestMetadata metadata for the PermissionLookupEntityRequest.
 *
 * @generated from protobuf message base.v1.PermissionLookupEntityRequestMetadata
 */
export interface PermissionLookupEntityRequestMetadata {
    /**
     * Version of the schema.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
    /**
     * Token associated with the snap.
     *
     * @generated from protobuf field: string snap_token = 2 [json_name = "snap_token"];
     */
    snapToken: string;
    /**
     * Depth of lookup, required, must be greater or equal to 3.
     *
     * @generated from protobuf field: int32 depth = 3;
     */
    depth: number;
}
/**
 * PermissionLookupEntityResponse is the response message for the LookupEntity method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionLookupEntityResponse
 */
export interface PermissionLookupEntityResponse {
    /**
     * List of identifiers for entities that match the lookup.
     *
     * @generated from protobuf field: repeated string entity_ids = 1 [json_name = "entity_ids"];
     */
    entityIds: string[];
    /**
     * continuous_token is a string that can be used to paginate and retrieve the next set of results.
     *
     * @generated from protobuf field: string continuous_token = 2 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
// LOOKUP STREAM

/**
 * PermissionLookupEntityStreamResponse is the response message for the LookupEntityStream method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionLookupEntityStreamResponse
 */
export interface PermissionLookupEntityStreamResponse {
    /**
     * Identifier for an entity that matches the lookup.
     *
     * @generated from protobuf field: string entity_id = 1 [json_name = "entity_id"];
     */
    entityId: string;
    /**
     * continuous_token is a string that can be used to paginate and retrieve the next set of results.
     *
     * @generated from protobuf field: string continuous_token = 2 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
/**
 * PermissionEntityFilterRequest is the request message for the LookupEntityStream method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionEntityFilterRequest
 */
export interface PermissionEntityFilterRequest {
    /**
     * Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * Metadata associated with this request, required.
     *
     * @generated from protobuf field: base.v1.PermissionEntityFilterRequestMetadata metadata = 2;
     */
    metadata?: PermissionEntityFilterRequestMetadata;
    /**
     * Reference to the entity to filter.
     *
     * @generated from protobuf field: base.v1.Entrance entrance = 3;
     */
    entrance?: Entrance;
    /**
     * Subject for which to check the permission.
     *
     * @generated from protobuf field: base.v1.Subject subject = 4;
     */
    subject?: Subject;
    /**
     * Context associated with this request.
     *
     * @generated from protobuf field: base.v1.Context context = 5;
     */
    context?: Context;
    /**
     * Scope: A map that associates entity types with lists of identifiers. Each entry
     * helps filter requests by specifying which entities are relevant to the operation.
     *
     * @generated from protobuf field: map<string, base.v1.StringArrayValue> scope = 6;
     */
    scope: {
        [key: string]: StringArrayValue;
    };
    /**
     * cursor is an optional parameter used for pagination.
     * It should be the value received in the previous response.
     *
     * @generated from protobuf field: string cursor = 7;
     */
    cursor: string;
}
/**
 * PermissionEntityFilterRequestMetadata metadata for the PermissionEntityFilterRequest.
 *
 * @generated from protobuf message base.v1.PermissionEntityFilterRequestMetadata
 */
export interface PermissionEntityFilterRequestMetadata {
    /**
     * Version of the schema.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
    /**
     * Token associated with the snap.
     *
     * @generated from protobuf field: string snap_token = 2 [json_name = "snap_token"];
     */
    snapToken: string;
    /**
     * Depth of lookup, required, must be greater or equal to 3.
     *
     * @generated from protobuf field: int32 depth = 3;
     */
    depth: number;
}
// LOOKUP SUBJECT

/**
 * PermissionLookupSubjectRequest is the request message for the LookupSubject method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionLookupSubjectRequest
 */
export interface PermissionLookupSubjectRequest {
    /**
     * Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * Metadata associated with this request, required.
     *
     * @generated from protobuf field: base.v1.PermissionLookupSubjectRequestMetadata metadata = 2;
     */
    metadata?: PermissionLookupSubjectRequestMetadata;
    /**
     * Entity for which to check the permission, required.
     *
     * @generated from protobuf field: base.v1.Entity entity = 3;
     */
    entity?: Entity;
    /**
     * Permission to be checked, can be a permission or relation. Required, and must match the pattern "^([a-zA-Z][a-zA-Z0-9_]{1,62}[a-zA-Z0-9])$", max 64 bytes.
     *
     * @generated from protobuf field: string permission = 4;
     */
    permission: string;
    /**
     * Reference to the subject to lookup.
     *
     * @generated from protobuf field: base.v1.RelationReference subject_reference = 5 [json_name = "subject_reference"];
     */
    subjectReference?: RelationReference;
    /**
     * Context associated with this request.
     *
     * @generated from protobuf field: base.v1.Context context = 6;
     */
    context?: Context;
    /**
     * Additional arguments associated with this request.
     *
     * @generated from protobuf field: repeated base.v1.Argument arguments = 7;
     */
    arguments: Argument[];
    /**
     * page_size is the number of subjects to be returned in the response.
     * The value should be between 1 and 100.
     *
     * @generated from protobuf field: uint32 page_size = 8 [json_name = "page_size"];
     */
    pageSize: number;
    /**
     * continuous_token is an optional parameter used for pagination.
     * It should be the value received in the previous response.
     *
     * @generated from protobuf field: string continuous_token = 9 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
/**
 * PermissionLookupSubjectRequestMetadata metadata for the PermissionLookupSubjectRequest.
 *
 * @generated from protobuf message base.v1.PermissionLookupSubjectRequestMetadata
 */
export interface PermissionLookupSubjectRequestMetadata {
    /**
     * Version of the schema.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
    /**
     * Token associated with the snap.
     *
     * @generated from protobuf field: string snap_token = 2 [json_name = "snap_token"];
     */
    snapToken: string;
    /**
     * Depth of the check, must be greater than or equal to 3.
     *
     * @generated from protobuf field: int32 depth = 3;
     */
    depth: number;
}
/**
 * PermissionLookupSubjectResponse is the response message for the LookupSubject method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionLookupSubjectResponse
 */
export interface PermissionLookupSubjectResponse {
    /**
     * List of identifiers for subjects that match the lookup.
     *
     * @generated from protobuf field: repeated string subject_ids = 1 [json_name = "subject_ids"];
     */
    subjectIds: string[];
    /**
     * continuous_token is a string that can be used to paginate and retrieve the next set of results.
     *
     * @generated from protobuf field: string continuous_token = 2 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
// SUBJECT PERMISSION

/**
 * PermissionSubjectPermissionRequest is the request message for the SubjectPermission method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionSubjectPermissionRequest
 */
export interface PermissionSubjectPermissionRequest {
    /**
     * Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * Metadata associated with this request, required.
     *
     * @generated from protobuf field: base.v1.PermissionSubjectPermissionRequestMetadata metadata = 2;
     */
    metadata?: PermissionSubjectPermissionRequestMetadata;
    /**
     * Entity for which to check the permission, required.
     *
     * @generated from protobuf field: base.v1.Entity entity = 3;
     */
    entity?: Entity;
    /**
     * Subject for which to check the permission, required.
     *
     * @generated from protobuf field: base.v1.Subject subject = 4;
     */
    subject?: Subject;
    /**
     * Context associated with this request.
     *
     * @generated from protobuf field: base.v1.Context context = 5;
     */
    context?: Context;
}
/**
 * PermissionSubjectPermissionRequestMetadata metadata for the PermissionSubjectPermissionRequest.
 *
 * @generated from protobuf message base.v1.PermissionSubjectPermissionRequestMetadata
 */
export interface PermissionSubjectPermissionRequestMetadata {
    /**
     * Version of the schema.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
    /**
     * Token associated with the snap.
     *
     * @generated from protobuf field: string snap_token = 2 [json_name = "snap_token"];
     */
    snapToken: string;
    /**
     * Whether to only check permissions.
     *
     * @generated from protobuf field: bool only_permission = 3 [json_name = "only_permission"];
     */
    onlyPermission: boolean;
    /**
     * Depth of the check, must be greater than or equal to 3.
     *
     * @generated from protobuf field: int32 depth = 4;
     */
    depth: number;
}
/**
 * PermissionSubjectPermissionResponse is the response message for the SubjectPermission method in the Permission service.
 *
 * @generated from protobuf message base.v1.PermissionSubjectPermissionResponse
 */
export interface PermissionSubjectPermissionResponse {
    /**
     * Map of results for each permission check.
     *
     * @generated from protobuf field: map<string, base.v1.CheckResult> results = 1;
     */
    results: {
        [key: string]: CheckResult;
    };
}
/**
 * WatchRequest is the request message for the Watch RPC. It contains the
 * details needed to establish a watch stream.
 *
 * @generated from protobuf message base.v1.WatchRequest
 */
export interface WatchRequest {
    /**
     * Identifier of the tenant, required, and must match the pattern "[a-zA-Z0-9-,]+", max 64 bytes.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * Snap token to be used for watching.
     *
     * @generated from protobuf field: string snap_token = 2 [json_name = "snap_token"];
     */
    snapToken: string;
}
/**
 * WatchResponse is the response message for the Watch RPC. It contains the
 * changes in the data that are being watched.
 *
 * @generated from protobuf message base.v1.WatchResponse
 */
export interface WatchResponse {
    /**
     * Changes in the data.
     *
     * @generated from protobuf field: base.v1.DataChanges changes = 1;
     */
    changes?: DataChanges;
}
// WRITE

/**
 * SchemaWriteRequest is the request message for the Write method in the Schema service.
 * It contains tenant_id and the schema to be written.
 *
 * @generated from protobuf message base.v1.SchemaWriteRequest
 */
export interface SchemaWriteRequest {
    /**
     * tenant_id is a string that identifies the tenant. It must match the pattern "[a-zA-Z0-9-,]+",
     * be a maximum of 64 bytes, and must not be empty.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * schema is the string representation of the schema to be written.
     *
     * @generated from protobuf field: string schema = 2;
     */
    schema: string;
}
/**
 * SchemaWriteResponse is the response message for the Write method in the Schema service.
 * It returns the version of the written schema.
 *
 * @generated from protobuf message base.v1.SchemaWriteResponse
 */
export interface SchemaWriteResponse {
    /**
     * schema_version is the string that identifies the version of the written schema.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
}
// PARTIAL WRITE

/**
 * It contains the tenant_id to identify the tenant and metadata of the schema to be edited,
 * with the corresponding edits to various entities
 *
 * @generated from protobuf message base.v1.SchemaPartialWriteRequest
 */
export interface SchemaPartialWriteRequest {
    /**
     * tenant_id is a string that identifies the tenant. It must match the pattern "[a-zA-Z0-9-,]+",
     * be a maximum of 64 bytes, and must not be empty.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * metadata is the additional information needed for the Partial Write request.
     *
     * @generated from protobuf field: base.v1.SchemaPartialWriteRequestMetadata metadata = 2;
     */
    metadata?: SchemaPartialWriteRequestMetadata;
    /**
     * Map of entity name with the values needed to be updated
     *
     * @generated from protobuf field: map<string, base.v1.Partials> partials = 3;
     */
    partials: {
        [key: string]: Partials;
    };
}
/**
 * SchemaPartialWriteRequestMetadata provides additional information for the Schema Partial Write request.
 * It contains schema_version to specify which version of the schema should be read.
 *
 * @generated from protobuf message base.v1.SchemaPartialWriteRequestMetadata
 */
export interface SchemaPartialWriteRequestMetadata {
    /**
     * schema_version is the string that identifies the version of the schema to be read.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
}
/**
 * SchemaPartialWriteResponse is the response message for the Parietal Write method in the Schema service.
 * It returns the requested schema.
 *
 * @generated from protobuf message base.v1.SchemaPartialWriteResponse
 */
export interface SchemaPartialWriteResponse {
    /**
     * schema_version is the string that identifies the version of the written schema.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
}
// READ

/**
 * SchemaReadRequest is the request message for the Read method in the Schema service.
 * It contains tenant_id and metadata about the schema to be read.
 *
 * @generated from protobuf message base.v1.SchemaReadRequest
 */
export interface SchemaReadRequest {
    /**
     * tenant_id is a string that identifies the tenant. It must match the pattern "[a-zA-Z0-9-,]+",
     * be a maximum of 64 bytes, and must not be empty.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * metadata is the additional information needed for the Read request.
     *
     * @generated from protobuf field: base.v1.SchemaReadRequestMetadata metadata = 2;
     */
    metadata?: SchemaReadRequestMetadata;
}
/**
 * SchemaReadRequestMetadata provides additional information for the Schema Read request.
 * It contains schema_version to specify which version of the schema should be read.
 *
 * @generated from protobuf message base.v1.SchemaReadRequestMetadata
 */
export interface SchemaReadRequestMetadata {
    /**
     * schema_version is the string that identifies the version of the schema to be read.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
}
/**
 * SchemaReadResponse is the response message for the Read method in the Schema service.
 * It returns the requested schema.
 *
 * @generated from protobuf message base.v1.SchemaReadResponse
 */
export interface SchemaReadResponse {
    /**
     * schema is the SchemaDefinition that represents the read schema.
     *
     * @generated from protobuf field: base.v1.SchemaDefinition schema = 1;
     */
    schema?: SchemaDefinition;
}
// LIST

/**
 * SchemaListRequest is the request message for the List method in the Schema service.
 * It contains tenant_id for which the schemas are to be listed.
 *
 * @generated from protobuf message base.v1.SchemaListRequest
 */
export interface SchemaListRequest {
    /**
     * tenant_id is a string that identifies the tenant. It must match the pattern "[a-zA-Z0-9-,]+",
     * be a maximum of 64 bytes, and must not be empty.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * page_size is the number of schemas to be returned in the response.
     * The value should be between 1 and 100.
     *
     * @generated from protobuf field: uint32 page_size = 2 [json_name = "page_size"];
     */
    pageSize: number;
    /**
     * continuous_token is an optional parameter used for pagination.
     * It should be the value received in the previous response.
     *
     * @generated from protobuf field: string continuous_token = 3 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
/**
 * SchemaListResponse is the response message for the List method in the Schema service.
 * It returns a paginated list of schemas
 *
 * @generated from protobuf message base.v1.SchemaListResponse
 */
export interface SchemaListResponse {
    /**
     * head of the schemas is the latest version available for the tenant
     *
     * @generated from protobuf field: string head = 1;
     */
    head: string;
    /**
     * list of schema versions with creation timestamps
     *
     * @generated from protobuf field: repeated base.v1.SchemaList schemas = 2;
     */
    schemas: SchemaList[];
    /**
     * continuous_token is a string that can be used to paginate and retrieve the next set of results.
     *
     * @generated from protobuf field: string continuous_token = 3 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
/**
 * SchemaList provides a list of schema versions with their corresponding creation timestamps
 *
 * @generated from protobuf message base.v1.SchemaList
 */
export interface SchemaList {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf field: string created_at = 2 [json_name = "created_at"];
     */
    createdAt: string;
}
/**
 * DataWriteRequest defines the structure of a request for writing data.
 * It contains the necessary information such as tenant_id, metadata,
 * tuples and attributes for the write operation.
 *
 * @generated from protobuf message base.v1.DataWriteRequest
 */
export interface DataWriteRequest {
    /**
     * tenant_id represents the unique identifier of the tenant for which data is written.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * metadata holds additional data related to the request.
     *
     * @generated from protobuf field: base.v1.DataWriteRequestMetadata metadata = 2;
     */
    metadata?: DataWriteRequestMetadata;
    /**
     * tuples contains the list of tuples (entity-relation-entity triples) that need to be written.
     *
     * @generated from protobuf field: repeated base.v1.Tuple tuples = 3;
     */
    tuples: Tuple[];
    /**
     * attributes contains the list of attributes (entity-attribute-value triples) that need to be written.
     *
     * @generated from protobuf field: repeated base.v1.Attribute attributes = 4;
     */
    attributes: Attribute[];
}
/**
 * DataWriteRequestMetadata defines the structure of metadata for a write request.
 * It includes the schema version of the data to be written.
 *
 * @generated from protobuf message base.v1.DataWriteRequestMetadata
 */
export interface DataWriteRequestMetadata {
    /**
     * schema_version represents the version of the schema for the data being written.
     *
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
}
/**
 * DataWriteResponse defines the structure of the response after writing data.
 * It contains the snap_token generated after the write operation.
 *
 * @generated from protobuf message base.v1.DataWriteResponse
 */
export interface DataWriteResponse {
    /**
     * snap_token is the token generated after the data write operation, representing a snapshot of the data.
     *
     * @generated from protobuf field: string snap_token = 1 [json_name = "snap_token"];
     */
    snapToken: string;
}
/**
 * Represents a request to write relationship data.
 *
 * @generated from protobuf message base.v1.RelationshipWriteRequest
 */
export interface RelationshipWriteRequest {
    /**
     * Unique identifier for the tenant with specific constraints.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * Metadata for the request. It's required.
     *
     * @generated from protobuf field: base.v1.RelationshipWriteRequestMetadata metadata = 2;
     */
    metadata?: RelationshipWriteRequestMetadata;
    /**
     * List of tuples for the request. Must have between 1 and 100 items.
     *
     * @generated from protobuf field: repeated base.v1.Tuple tuples = 3;
     */
    tuples: Tuple[];
}
/**
 * RelationshipWriteRequestMetadata
 *
 * @generated from protobuf message base.v1.RelationshipWriteRequestMetadata
 */
export interface RelationshipWriteRequestMetadata {
    /**
     * @generated from protobuf field: string schema_version = 1 [json_name = "schema_version"];
     */
    schemaVersion: string;
}
/**
 * RelationshipWriteResponse
 *
 * @generated from protobuf message base.v1.RelationshipWriteResponse
 */
export interface RelationshipWriteResponse {
    /**
     * @generated from protobuf field: string snap_token = 1 [json_name = "snap_token"];
     */
    snapToken: string;
}
/**
 * RelationshipReadRequest defines the structure of a request for reading relationships.
 * It contains the necessary information such as tenant_id, metadata, and filter for the read operation.
 *
 * @generated from protobuf message base.v1.RelationshipReadRequest
 */
export interface RelationshipReadRequest {
    /**
     * tenant_id represents the unique identifier of the tenant for which relationships are read.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * metadata holds additional data related to the request.
     *
     * @generated from protobuf field: base.v1.RelationshipReadRequestMetadata metadata = 2;
     */
    metadata?: RelationshipReadRequestMetadata;
    /**
     * filter is used to specify criteria for the data that needs to be read.
     *
     * @generated from protobuf field: base.v1.TupleFilter filter = 3;
     */
    filter?: TupleFilter;
    /**
     * page_size specifies the number of results to return in a single page.
     * If more results are available, a continuous_token is included in the response.
     *
     * @generated from protobuf field: uint32 page_size = 4 [json_name = "page_size"];
     */
    pageSize: number;
    /**
     * continuous_token is used in case of paginated reads to get the next page of results.
     *
     * @generated from protobuf field: string continuous_token = 5 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
/**
 * RelationshipReadRequestMetadata defines the structure of the metadata for a read request focused on relationships.
 * It includes the snap_token associated with a particular state of the database.
 *
 * @generated from protobuf message base.v1.RelationshipReadRequestMetadata
 */
export interface RelationshipReadRequestMetadata {
    /**
     * snap_token represents a specific state or "snapshot" of the database.
     *
     * @generated from protobuf field: string snap_token = 1 [json_name = "snap_token"];
     */
    snapToken: string;
}
/**
 * RelationshipReadResponse defines the structure of the response after reading relationships.
 * It includes the tuples representing the relationships and a continuous token for handling result pagination.
 *
 * @generated from protobuf message base.v1.RelationshipReadResponse
 */
export interface RelationshipReadResponse {
    /**
     * tuples is a list of the relationships retrieved in the read operation, represented as entity-relation-entity triples.
     *
     * @generated from protobuf field: repeated base.v1.Tuple tuples = 1;
     */
    tuples: Tuple[];
    /**
     * continuous_token is used in the case of paginated reads to retrieve the next page of results.
     *
     * @generated from protobuf field: string continuous_token = 2 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
/**
 * AttributeReadRequest defines the structure of a request for reading attributes.
 * It includes the tenant_id, metadata, attribute filter, page size for pagination, and a continuous token for multi-page results.
 *
 * @generated from protobuf message base.v1.AttributeReadRequest
 */
export interface AttributeReadRequest {
    /**
     * tenant_id represents the unique identifier of the tenant from which the attributes are being read.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * metadata holds additional information related to the request.
     *
     * @generated from protobuf field: base.v1.AttributeReadRequestMetadata metadata = 2;
     */
    metadata?: AttributeReadRequestMetadata;
    /**
     * filter specifies the criteria used to select the attributes that should be returned.
     *
     * @generated from protobuf field: base.v1.AttributeFilter filter = 3;
     */
    filter?: AttributeFilter;
    /**
     * page_size specifies the number of results to return in a single page.
     * If more results are available, a continuous_token is included in the response.
     *
     * @generated from protobuf field: uint32 page_size = 4 [json_name = "page_size"];
     */
    pageSize: number;
    /**
     * continuous_token is used in case of paginated reads to get the next page of results.
     *
     * @generated from protobuf field: string continuous_token = 5 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
/**
 * AttributeReadRequestMetadata defines the structure for the metadata of an attribute read request.
 * It includes the snap_token associated with a particular state of the database.
 *
 * @generated from protobuf message base.v1.AttributeReadRequestMetadata
 */
export interface AttributeReadRequestMetadata {
    /**
     * snap_token represents a specific state or "snapshot" of the database.
     *
     * @generated from protobuf field: string snap_token = 1 [json_name = "snap_token"];
     */
    snapToken: string;
}
/**
 * AttributeReadResponse defines the structure of the response to an attribute read request.
 * It includes the attributes retrieved and a continuous token for handling result pagination.
 *
 * @generated from protobuf message base.v1.AttributeReadResponse
 */
export interface AttributeReadResponse {
    /**
     * attributes is a list of the attributes retrieved in the read operation.
     *
     * @generated from protobuf field: repeated base.v1.Attribute attributes = 1;
     */
    attributes: Attribute[];
    /**
     * continuous_token is used in the case of paginated reads to retrieve the next page of results.
     *
     * @generated from protobuf field: string continuous_token = 2 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
/**
 * DataDeleteRequest defines the structure of a request to delete data.
 * It includes the tenant_id and filters for selecting tuples and attributes to be deleted.
 *
 * @generated from protobuf message base.v1.DataDeleteRequest
 */
export interface DataDeleteRequest {
    /**
     * tenant_id represents the unique identifier of the tenant from which the data will be deleted.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * tuple_filter specifies the criteria used to select the tuples that should be deleted.
     *
     * @generated from protobuf field: base.v1.TupleFilter tuple_filter = 2 [json_name = "tuple_filter"];
     */
    tupleFilter?: TupleFilter;
    /**
     * attribute_filter specifies the criteria used to select the attributes that should be deleted.
     *
     * @generated from protobuf field: base.v1.AttributeFilter attribute_filter = 3 [json_name = "attribute_filter"];
     */
    attributeFilter?: AttributeFilter;
}
/**
 * DataDeleteResponse defines the structure of the response to a data delete request.
 * It includes a snap_token representing the state of the database after the deletion.
 *
 * @generated from protobuf message base.v1.DataDeleteResponse
 */
export interface DataDeleteResponse {
    /**
     * snap_token represents the state of the database after the requested deletions.
     *
     * @generated from protobuf field: string snap_token = 1 [json_name = "snap_token"];
     */
    snapToken: string;
}
/**
 * RelationshipDeleteRequest
 *
 * @generated from protobuf message base.v1.RelationshipDeleteRequest
 */
export interface RelationshipDeleteRequest {
    /**
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * @generated from protobuf field: base.v1.TupleFilter filter = 2;
     */
    filter?: TupleFilter;
}
/**
 * RelationshipDeleteResponse
 *
 * @generated from protobuf message base.v1.RelationshipDeleteResponse
 */
export interface RelationshipDeleteResponse {
    /**
     * @generated from protobuf field: string snap_token = 1 [json_name = "snap_token"];
     */
    snapToken: string;
}
/**
 * BundleRunRequest is used to request the execution of a bundle.
 * It includes tenant_id, the name of the bundle, and additional arguments for execution.
 *
 * @generated from protobuf message base.v1.BundleRunRequest
 */
export interface BundleRunRequest {
    /**
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * Name of the bundle to be executed.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * Additional key-value pairs for execution arguments.
     *
     * @generated from protobuf field: map<string, string> arguments = 3;
     */
    arguments: {
        [key: string]: string;
    };
}
/**
 * BundleRunResponse is the response for a BundleRunRequest.
 * It includes a snap_token, which may be used for tracking the execution or its results.
 *
 * @generated from protobuf message base.v1.BundleRunResponse
 */
export interface BundleRunResponse {
    /**
     * @generated from protobuf field: string snap_token = 1 [json_name = "snap_token"];
     */
    snapToken: string;
}
/**
 * BundleWriteRequest is used to request the writing of a bundle.
 * It contains the tenant_id to identify the tenant and the Bundles object.
 *
 * @generated from protobuf message base.v1.BundleWriteRequest
 */
export interface BundleWriteRequest {
    /**
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * @generated from protobuf field: repeated base.v1.DataBundle bundles = 2;
     */
    bundles: DataBundle[]; // Contains the bundle data to be written.
}
/**
 * BundleWriteResponse is the response for a BundleWriteRequest.
 * It includes a name which could be used as an identifier or acknowledgment.
 *
 * @generated from protobuf message base.v1.BundleWriteResponse
 */
export interface BundleWriteResponse {
    /**
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[]; // Identifier or acknowledgment of the written bundle.
}
/**
 * @generated from protobuf message base.v1.BundleReadRequest
 */
export interface BundleReadRequest {
    /**
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message base.v1.BundleReadResponse
 */
export interface BundleReadResponse {
    /**
     * @generated from protobuf field: base.v1.DataBundle bundle = 1;
     */
    bundle?: DataBundle;
}
/**
 * BundleDeleteRequest is used to request the deletion of a bundle.
 * It contains the tenant_id to specify the tenant and the name of the bundle to be deleted.
 *
 * @generated from protobuf message base.v1.BundleDeleteRequest
 */
export interface BundleDeleteRequest {
    /**
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string; // Name of the bundle to be deleted.
}
/**
 * @generated from protobuf message base.v1.BundleDeleteResponse
 */
export interface BundleDeleteResponse {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * TenantCreateRequest is the message used for the request to create a tenant.
 *
 * @generated from protobuf message base.v1.TenantCreateRequest
 */
export interface TenantCreateRequest {
    /**
     * id is a unique identifier for the tenant.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * name is the name of the tenant.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * TenantCreateResponse is the message returned from the request to create a tenant.
 *
 * @generated from protobuf message base.v1.TenantCreateResponse
 */
export interface TenantCreateResponse {
    /**
     * tenant is the created tenant information.
     *
     * @generated from protobuf field: base.v1.Tenant tenant = 1;
     */
    tenant?: Tenant;
}
/**
 * TenantDeleteRequest is the message used for the request to delete a tenant.
 *
 * @generated from protobuf message base.v1.TenantDeleteRequest
 */
export interface TenantDeleteRequest {
    /**
     * id is the unique identifier of the tenant to be deleted.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * TenantDeleteResponse is the message returned from the request to delete a tenant.
 *
 * @generated from protobuf message base.v1.TenantDeleteResponse
 */
export interface TenantDeleteResponse {
    /**
     * tenant_id is the tenant id that was deleted.
     *
     * @generated from protobuf field: string tenant_id = 1 [json_name = "tenant_id"];
     */
    tenantId: string;
}
/**
 * TenantListRequest is the message used for the request to list all tenants.
 *
 * @generated from protobuf message base.v1.TenantListRequest
 */
export interface TenantListRequest {
    /**
     * page_size is the number of tenants to be returned in the response.
     * The value should be between 1 and 100.
     *
     * @generated from protobuf field: uint32 page_size = 1 [json_name = "page_size"];
     */
    pageSize: number;
    /**
     * continuous_token is an optional parameter used for pagination.
     * It should be the value received in the previous response.
     *
     * @generated from protobuf field: string continuous_token = 2 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
/**
 * TenantListResponse is the message returned from the request to list all tenants.
 *
 * @generated from protobuf message base.v1.TenantListResponse
 */
export interface TenantListResponse {
    /**
     * tenants is a list of tenants.
     *
     * @generated from protobuf field: repeated base.v1.Tenant tenants = 1;
     */
    tenants: Tenant[];
    /**
     * continuous_token is a string that can be used to paginate and retrieve the next set of results.
     *
     * @generated from protobuf field: string continuous_token = 2 [json_name = "continuous_token"];
     */
    continuousToken: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class PermissionCheckRequest$Type extends MessageType<PermissionCheckRequest> {
    constructor() {
        super("base.v1.PermissionCheckRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => PermissionCheckRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "entity", kind: "message", T: () => Entity, options: { "validate.rules": { message: { required: true } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { example: "\"repository:1\"" } } },
            { no: 4, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The action the user wants to perform on the resource" } } },
            { no: 5, name: "subject", kind: "message", T: () => Subject, options: { "validate.rules": { message: { required: true } } } },
            { no: 6, name: "context", kind: "message", T: () => Context, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Contextual data that can be dynamically added to permission check requests. See details on [Contextual Data](../../operations/contextual-tuples)" } } },
            { no: 7, name: "arguments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Argument }
        ]);
    }
    create(value?: PartialMessage<PermissionCheckRequest>): PermissionCheckRequest {
        const message = { tenantId: "", permission: "", arguments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionCheckRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionCheckRequest): PermissionCheckRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.PermissionCheckRequestMetadata metadata */ 2:
                    message.metadata = PermissionCheckRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* base.v1.Entity entity */ 3:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* string permission */ 4:
                    message.permission = reader.string();
                    break;
                case /* base.v1.Subject subject */ 5:
                    message.subject = Subject.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* base.v1.Context context */ 6:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* repeated base.v1.Argument arguments */ 7:
                    message.arguments.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionCheckRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.PermissionCheckRequestMetadata metadata = 2; */
        if (message.metadata)
            PermissionCheckRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Entity entity = 3; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 4; */
        if (message.permission !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.permission);
        /* base.v1.Subject subject = 5; */
        if (message.subject)
            Subject.internalBinaryWrite(message.subject, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Context context = 6; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated base.v1.Argument arguments = 7; */
        for (let i = 0; i < message.arguments.length; i++)
            Argument.internalBinaryWrite(message.arguments[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionCheckRequest
 */
export const PermissionCheckRequest = new PermissionCheckRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionCheckRequestMetadata$Type extends MessageType<PermissionCheckRequestMetadata> {
    constructor() {
        super("base.v1.PermissionCheckRequestMetadata", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)" } } },
            { no: 3, name: "depth", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 3 } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Query limit when if recursive database queries got in loop" } } }
        ]);
    }
    create(value?: PartialMessage<PermissionCheckRequestMetadata>): PermissionCheckRequestMetadata {
        const message = { schemaVersion: "", snapToken: "", depth: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionCheckRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionCheckRequestMetadata): PermissionCheckRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                case /* string snap_token = 2 [json_name = "snap_token"];*/ 2:
                    message.snapToken = reader.string();
                    break;
                case /* int32 depth */ 3:
                    message.depth = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionCheckRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        /* string snap_token = 2 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.snapToken);
        /* int32 depth = 3; */
        if (message.depth !== 0)
            writer.tag(3, WireType.Varint).int32(message.depth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionCheckRequestMetadata
 */
export const PermissionCheckRequestMetadata = new PermissionCheckRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionCheckResponse$Type extends MessageType<PermissionCheckResponse> {
    constructor() {
        super("base.v1.PermissionCheckResponse", [
            { no: 1, name: "can", kind: "enum", T: () => ["base.v1.CheckResult", CheckResult, "CHECK_RESULT_"] },
            { no: 2, name: "metadata", kind: "message", T: () => PermissionCheckResponseMetadata }
        ]);
    }
    create(value?: PartialMessage<PermissionCheckResponse>): PermissionCheckResponse {
        const message = { can: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionCheckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionCheckResponse): PermissionCheckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.CheckResult can */ 1:
                    message.can = reader.int32();
                    break;
                case /* base.v1.PermissionCheckResponseMetadata metadata */ 2:
                    message.metadata = PermissionCheckResponseMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionCheckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.CheckResult can = 1; */
        if (message.can !== 0)
            writer.tag(1, WireType.Varint).int32(message.can);
        /* base.v1.PermissionCheckResponseMetadata metadata = 2; */
        if (message.metadata)
            PermissionCheckResponseMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionCheckResponse
 */
export const PermissionCheckResponse = new PermissionCheckResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionCheckResponseMetadata$Type extends MessageType<PermissionCheckResponseMetadata> {
    constructor() {
        super("base.v1.PermissionCheckResponseMetadata", [
            { no: 1, name: "check_count", kind: "scalar", jsonName: "check_count", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PermissionCheckResponseMetadata>): PermissionCheckResponseMetadata {
        const message = { checkCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionCheckResponseMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionCheckResponseMetadata): PermissionCheckResponseMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 check_count = 1 [json_name = "check_count"];*/ 1:
                    message.checkCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionCheckResponseMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 check_count = 1 [json_name = "check_count"]; */
        if (message.checkCount !== 0)
            writer.tag(1, WireType.Varint).int32(message.checkCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionCheckResponseMetadata
 */
export const PermissionCheckResponseMetadata = new PermissionCheckResponseMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionExpandRequest$Type extends MessageType<PermissionExpandRequest> {
    constructor() {
        super("base.v1.PermissionExpandRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => PermissionExpandRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "entity", kind: "message", T: () => Entity, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$", ignoreEmpty: true } } } },
            { no: 5, name: "context", kind: "message", T: () => Context },
            { no: 6, name: "arguments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Argument }
        ]);
    }
    create(value?: PartialMessage<PermissionExpandRequest>): PermissionExpandRequest {
        const message = { tenantId: "", permission: "", arguments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionExpandRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionExpandRequest): PermissionExpandRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.PermissionExpandRequestMetadata metadata */ 2:
                    message.metadata = PermissionExpandRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* base.v1.Entity entity */ 3:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* string permission */ 4:
                    message.permission = reader.string();
                    break;
                case /* base.v1.Context context */ 5:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* repeated base.v1.Argument arguments */ 6:
                    message.arguments.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionExpandRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.PermissionExpandRequestMetadata metadata = 2; */
        if (message.metadata)
            PermissionExpandRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Entity entity = 3; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 4; */
        if (message.permission !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.permission);
        /* base.v1.Context context = 5; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated base.v1.Argument arguments = 6; */
        for (let i = 0; i < message.arguments.length; i++)
            Argument.internalBinaryWrite(message.arguments[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionExpandRequest
 */
export const PermissionExpandRequest = new PermissionExpandRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionExpandRequestMetadata$Type extends MessageType<PermissionExpandRequestMetadata> {
    constructor() {
        super("base.v1.PermissionExpandRequestMetadata", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)." } } }
        ]);
    }
    create(value?: PartialMessage<PermissionExpandRequestMetadata>): PermissionExpandRequestMetadata {
        const message = { schemaVersion: "", snapToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionExpandRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionExpandRequestMetadata): PermissionExpandRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                case /* string snap_token = 2 [json_name = "snap_token"];*/ 2:
                    message.snapToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionExpandRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        /* string snap_token = 2 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.snapToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionExpandRequestMetadata
 */
export const PermissionExpandRequestMetadata = new PermissionExpandRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionExpandResponse$Type extends MessageType<PermissionExpandResponse> {
    constructor() {
        super("base.v1.PermissionExpandResponse", [
            { no: 1, name: "tree", kind: "message", T: () => Expand }
        ]);
    }
    create(value?: PartialMessage<PermissionExpandResponse>): PermissionExpandResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionExpandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionExpandResponse): PermissionExpandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.Expand tree */ 1:
                    message.tree = Expand.internalBinaryRead(reader, reader.uint32(), options, message.tree);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionExpandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.Expand tree = 1; */
        if (message.tree)
            Expand.internalBinaryWrite(message.tree, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionExpandResponse
 */
export const PermissionExpandResponse = new PermissionExpandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionLookupEntityRequest$Type extends MessageType<PermissionLookupEntityRequest> {
    constructor() {
        super("base.v1.PermissionLookupEntityRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => PermissionLookupEntityRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "entity_type", kind: "scalar", jsonName: "entity_type", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$", ignoreEmpty: false } } } },
            { no: 4, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$", ignoreEmpty: false } } } },
            { no: 5, name: "subject", kind: "message", T: () => Subject, options: { "validate.rules": { message: { required: true } } } },
            { no: 6, name: "context", kind: "message", T: () => Context },
            { no: 7, name: "scope", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => StringArrayValue } },
            { no: 8, name: "page_size", kind: "scalar", jsonName: "page_size", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 1, ignoreEmpty: true } } } },
            { no: 9, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<PermissionLookupEntityRequest>): PermissionLookupEntityRequest {
        const message = { tenantId: "", entityType: "", permission: "", scope: {}, pageSize: 0, continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionLookupEntityRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionLookupEntityRequest): PermissionLookupEntityRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.PermissionLookupEntityRequestMetadata metadata */ 2:
                    message.metadata = PermissionLookupEntityRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* string entity_type = 3 [json_name = "entity_type"];*/ 3:
                    message.entityType = reader.string();
                    break;
                case /* string permission */ 4:
                    message.permission = reader.string();
                    break;
                case /* base.v1.Subject subject */ 5:
                    message.subject = Subject.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* base.v1.Context context */ 6:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* map<string, base.v1.StringArrayValue> scope */ 7:
                    this.binaryReadMap7(message.scope, reader, options);
                    break;
                case /* uint32 page_size = 8 [json_name = "page_size"];*/ 8:
                    message.pageSize = reader.uint32();
                    break;
                case /* string continuous_token = 9 [json_name = "continuous_token"];*/ 9:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: PermissionLookupEntityRequest["scope"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PermissionLookupEntityRequest["scope"] | undefined, val: PermissionLookupEntityRequest["scope"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = StringArrayValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.PermissionLookupEntityRequest.scope");
            }
        }
        map[key ?? ""] = val ?? StringArrayValue.create();
    }
    internalBinaryWrite(message: PermissionLookupEntityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.PermissionLookupEntityRequestMetadata metadata = 2; */
        if (message.metadata)
            PermissionLookupEntityRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string entity_type = 3 [json_name = "entity_type"]; */
        if (message.entityType !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.entityType);
        /* string permission = 4; */
        if (message.permission !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.permission);
        /* base.v1.Subject subject = 5; */
        if (message.subject)
            Subject.internalBinaryWrite(message.subject, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Context context = 6; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* map<string, base.v1.StringArrayValue> scope = 7; */
        for (let k of Object.keys(message.scope)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            StringArrayValue.internalBinaryWrite(message.scope[k], writer, options);
            writer.join().join();
        }
        /* uint32 page_size = 8 [json_name = "page_size"]; */
        if (message.pageSize !== 0)
            writer.tag(8, WireType.Varint).uint32(message.pageSize);
        /* string continuous_token = 9 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionLookupEntityRequest
 */
export const PermissionLookupEntityRequest = new PermissionLookupEntityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionLookupEntityRequestMetadata$Type extends MessageType<PermissionLookupEntityRequestMetadata> {
    constructor() {
        super("base.v1.PermissionLookupEntityRequestMetadata", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)." } } },
            { no: 3, name: "depth", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 3 } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Query limit when if recursive database queries got in loop." } } }
        ]);
    }
    create(value?: PartialMessage<PermissionLookupEntityRequestMetadata>): PermissionLookupEntityRequestMetadata {
        const message = { schemaVersion: "", snapToken: "", depth: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionLookupEntityRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionLookupEntityRequestMetadata): PermissionLookupEntityRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                case /* string snap_token = 2 [json_name = "snap_token"];*/ 2:
                    message.snapToken = reader.string();
                    break;
                case /* int32 depth */ 3:
                    message.depth = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionLookupEntityRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        /* string snap_token = 2 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.snapToken);
        /* int32 depth = 3; */
        if (message.depth !== 0)
            writer.tag(3, WireType.Varint).int32(message.depth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionLookupEntityRequestMetadata
 */
export const PermissionLookupEntityRequestMetadata = new PermissionLookupEntityRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionLookupEntityResponse$Type extends MessageType<PermissionLookupEntityResponse> {
    constructor() {
        super("base.v1.PermissionLookupEntityResponse", [
            { no: 1, name: "entity_ids", kind: "scalar", jsonName: "entity_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PermissionLookupEntityResponse>): PermissionLookupEntityResponse {
        const message = { entityIds: [], continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionLookupEntityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionLookupEntityResponse): PermissionLookupEntityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string entity_ids = 1 [json_name = "entity_ids"];*/ 1:
                    message.entityIds.push(reader.string());
                    break;
                case /* string continuous_token = 2 [json_name = "continuous_token"];*/ 2:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionLookupEntityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string entity_ids = 1 [json_name = "entity_ids"]; */
        for (let i = 0; i < message.entityIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.entityIds[i]);
        /* string continuous_token = 2 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionLookupEntityResponse
 */
export const PermissionLookupEntityResponse = new PermissionLookupEntityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionLookupEntityStreamResponse$Type extends MessageType<PermissionLookupEntityStreamResponse> {
    constructor() {
        super("base.v1.PermissionLookupEntityStreamResponse", [
            { no: 1, name: "entity_id", kind: "scalar", jsonName: "entity_id", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PermissionLookupEntityStreamResponse>): PermissionLookupEntityStreamResponse {
        const message = { entityId: "", continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionLookupEntityStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionLookupEntityStreamResponse): PermissionLookupEntityStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string entity_id = 1 [json_name = "entity_id"];*/ 1:
                    message.entityId = reader.string();
                    break;
                case /* string continuous_token = 2 [json_name = "continuous_token"];*/ 2:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionLookupEntityStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string entity_id = 1 [json_name = "entity_id"]; */
        if (message.entityId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.entityId);
        /* string continuous_token = 2 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionLookupEntityStreamResponse
 */
export const PermissionLookupEntityStreamResponse = new PermissionLookupEntityStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionEntityFilterRequest$Type extends MessageType<PermissionEntityFilterRequest> {
    constructor() {
        super("base.v1.PermissionEntityFilterRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => PermissionEntityFilterRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "entrance", kind: "message", T: () => Entrance },
            { no: 4, name: "subject", kind: "message", T: () => Subject },
            { no: 5, name: "context", kind: "message", T: () => Context },
            { no: 6, name: "scope", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => StringArrayValue } },
            { no: 7, name: "cursor", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<PermissionEntityFilterRequest>): PermissionEntityFilterRequest {
        const message = { tenantId: "", scope: {}, cursor: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionEntityFilterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionEntityFilterRequest): PermissionEntityFilterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.PermissionEntityFilterRequestMetadata metadata */ 2:
                    message.metadata = PermissionEntityFilterRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* base.v1.Entrance entrance */ 3:
                    message.entrance = Entrance.internalBinaryRead(reader, reader.uint32(), options, message.entrance);
                    break;
                case /* base.v1.Subject subject */ 4:
                    message.subject = Subject.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* base.v1.Context context */ 5:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* map<string, base.v1.StringArrayValue> scope */ 6:
                    this.binaryReadMap6(message.scope, reader, options);
                    break;
                case /* string cursor */ 7:
                    message.cursor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap6(map: PermissionEntityFilterRequest["scope"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PermissionEntityFilterRequest["scope"] | undefined, val: PermissionEntityFilterRequest["scope"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = StringArrayValue.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.PermissionEntityFilterRequest.scope");
            }
        }
        map[key ?? ""] = val ?? StringArrayValue.create();
    }
    internalBinaryWrite(message: PermissionEntityFilterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.PermissionEntityFilterRequestMetadata metadata = 2; */
        if (message.metadata)
            PermissionEntityFilterRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Entrance entrance = 3; */
        if (message.entrance)
            Entrance.internalBinaryWrite(message.entrance, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Subject subject = 4; */
        if (message.subject)
            Subject.internalBinaryWrite(message.subject, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Context context = 5; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* map<string, base.v1.StringArrayValue> scope = 6; */
        for (let k of Object.keys(message.scope)) {
            writer.tag(6, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            StringArrayValue.internalBinaryWrite(message.scope[k], writer, options);
            writer.join().join();
        }
        /* string cursor = 7; */
        if (message.cursor !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.cursor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionEntityFilterRequest
 */
export const PermissionEntityFilterRequest = new PermissionEntityFilterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionEntityFilterRequestMetadata$Type extends MessageType<PermissionEntityFilterRequestMetadata> {
    constructor() {
        super("base.v1.PermissionEntityFilterRequestMetadata", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)." } } },
            { no: 3, name: "depth", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 3 } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Query limit when if recursive database queries got in loop." } } }
        ]);
    }
    create(value?: PartialMessage<PermissionEntityFilterRequestMetadata>): PermissionEntityFilterRequestMetadata {
        const message = { schemaVersion: "", snapToken: "", depth: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionEntityFilterRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionEntityFilterRequestMetadata): PermissionEntityFilterRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                case /* string snap_token = 2 [json_name = "snap_token"];*/ 2:
                    message.snapToken = reader.string();
                    break;
                case /* int32 depth */ 3:
                    message.depth = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionEntityFilterRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        /* string snap_token = 2 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.snapToken);
        /* int32 depth = 3; */
        if (message.depth !== 0)
            writer.tag(3, WireType.Varint).int32(message.depth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionEntityFilterRequestMetadata
 */
export const PermissionEntityFilterRequestMetadata = new PermissionEntityFilterRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionLookupSubjectRequest$Type extends MessageType<PermissionLookupSubjectRequest> {
    constructor() {
        super("base.v1.PermissionLookupSubjectRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => PermissionLookupSubjectRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "entity", kind: "message", T: () => Entity, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "permission", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "^[a-zA-Z_]{1,64}$", ignoreEmpty: false } } } },
            { no: 5, name: "subject_reference", kind: "message", jsonName: "subject_reference", T: () => RelationReference, options: { "validate.rules": { message: { required: true } } } },
            { no: 6, name: "context", kind: "message", T: () => Context },
            { no: 7, name: "arguments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Argument },
            { no: 8, name: "page_size", kind: "scalar", jsonName: "page_size", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 1, ignoreEmpty: true } } } },
            { no: 9, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<PermissionLookupSubjectRequest>): PermissionLookupSubjectRequest {
        const message = { tenantId: "", permission: "", arguments: [], pageSize: 0, continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionLookupSubjectRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionLookupSubjectRequest): PermissionLookupSubjectRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.PermissionLookupSubjectRequestMetadata metadata */ 2:
                    message.metadata = PermissionLookupSubjectRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* base.v1.Entity entity */ 3:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* string permission */ 4:
                    message.permission = reader.string();
                    break;
                case /* base.v1.RelationReference subject_reference = 5 [json_name = "subject_reference"];*/ 5:
                    message.subjectReference = RelationReference.internalBinaryRead(reader, reader.uint32(), options, message.subjectReference);
                    break;
                case /* base.v1.Context context */ 6:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* repeated base.v1.Argument arguments */ 7:
                    message.arguments.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 page_size = 8 [json_name = "page_size"];*/ 8:
                    message.pageSize = reader.uint32();
                    break;
                case /* string continuous_token = 9 [json_name = "continuous_token"];*/ 9:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionLookupSubjectRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.PermissionLookupSubjectRequestMetadata metadata = 2; */
        if (message.metadata)
            PermissionLookupSubjectRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Entity entity = 3; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string permission = 4; */
        if (message.permission !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.permission);
        /* base.v1.RelationReference subject_reference = 5 [json_name = "subject_reference"]; */
        if (message.subjectReference)
            RelationReference.internalBinaryWrite(message.subjectReference, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Context context = 6; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated base.v1.Argument arguments = 7; */
        for (let i = 0; i < message.arguments.length; i++)
            Argument.internalBinaryWrite(message.arguments[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* uint32 page_size = 8 [json_name = "page_size"]; */
        if (message.pageSize !== 0)
            writer.tag(8, WireType.Varint).uint32(message.pageSize);
        /* string continuous_token = 9 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionLookupSubjectRequest
 */
export const PermissionLookupSubjectRequest = new PermissionLookupSubjectRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionLookupSubjectRequestMetadata$Type extends MessageType<PermissionLookupSubjectRequestMetadata> {
    constructor() {
        super("base.v1.PermissionLookupSubjectRequestMetadata", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)." } } },
            { no: 3, name: "depth", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 3 } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Query limit when if recursive database queries got in loop." } } }
        ]);
    }
    create(value?: PartialMessage<PermissionLookupSubjectRequestMetadata>): PermissionLookupSubjectRequestMetadata {
        const message = { schemaVersion: "", snapToken: "", depth: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionLookupSubjectRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionLookupSubjectRequestMetadata): PermissionLookupSubjectRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                case /* string snap_token = 2 [json_name = "snap_token"];*/ 2:
                    message.snapToken = reader.string();
                    break;
                case /* int32 depth */ 3:
                    message.depth = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionLookupSubjectRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        /* string snap_token = 2 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.snapToken);
        /* int32 depth = 3; */
        if (message.depth !== 0)
            writer.tag(3, WireType.Varint).int32(message.depth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionLookupSubjectRequestMetadata
 */
export const PermissionLookupSubjectRequestMetadata = new PermissionLookupSubjectRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionLookupSubjectResponse$Type extends MessageType<PermissionLookupSubjectResponse> {
    constructor() {
        super("base.v1.PermissionLookupSubjectResponse", [
            { no: 1, name: "subject_ids", kind: "scalar", jsonName: "subject_ids", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PermissionLookupSubjectResponse>): PermissionLookupSubjectResponse {
        const message = { subjectIds: [], continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionLookupSubjectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionLookupSubjectResponse): PermissionLookupSubjectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string subject_ids = 1 [json_name = "subject_ids"];*/ 1:
                    message.subjectIds.push(reader.string());
                    break;
                case /* string continuous_token = 2 [json_name = "continuous_token"];*/ 2:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionLookupSubjectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string subject_ids = 1 [json_name = "subject_ids"]; */
        for (let i = 0; i < message.subjectIds.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.subjectIds[i]);
        /* string continuous_token = 2 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionLookupSubjectResponse
 */
export const PermissionLookupSubjectResponse = new PermissionLookupSubjectResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionSubjectPermissionRequest$Type extends MessageType<PermissionSubjectPermissionRequest> {
    constructor() {
        super("base.v1.PermissionSubjectPermissionRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => PermissionSubjectPermissionRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "entity", kind: "message", T: () => Entity, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "subject", kind: "message", T: () => Subject, options: { "validate.rules": { message: { required: true } } } },
            { no: 5, name: "context", kind: "message", T: () => Context }
        ]);
    }
    create(value?: PartialMessage<PermissionSubjectPermissionRequest>): PermissionSubjectPermissionRequest {
        const message = { tenantId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionSubjectPermissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionSubjectPermissionRequest): PermissionSubjectPermissionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.PermissionSubjectPermissionRequestMetadata metadata */ 2:
                    message.metadata = PermissionSubjectPermissionRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* base.v1.Entity entity */ 3:
                    message.entity = Entity.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* base.v1.Subject subject */ 4:
                    message.subject = Subject.internalBinaryRead(reader, reader.uint32(), options, message.subject);
                    break;
                case /* base.v1.Context context */ 5:
                    message.context = Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionSubjectPermissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.PermissionSubjectPermissionRequestMetadata metadata = 2; */
        if (message.metadata)
            PermissionSubjectPermissionRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Entity entity = 3; */
        if (message.entity)
            Entity.internalBinaryWrite(message.entity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Subject subject = 4; */
        if (message.subject)
            Subject.internalBinaryWrite(message.subject, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.Context context = 5; */
        if (message.context)
            Context.internalBinaryWrite(message.context, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionSubjectPermissionRequest
 */
export const PermissionSubjectPermissionRequest = new PermissionSubjectPermissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionSubjectPermissionRequestMetadata$Type extends MessageType<PermissionSubjectPermissionRequestMetadata> {
    constructor() {
        super("base.v1.PermissionSubjectPermissionRequestMetadata", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)." } } },
            { no: 3, name: "only_permission", kind: "scalar", jsonName: "only_permission", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "depth", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "validate.rules": { int32: { gte: 3 } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Query limit when if recursive database queries got in loop." } } }
        ]);
    }
    create(value?: PartialMessage<PermissionSubjectPermissionRequestMetadata>): PermissionSubjectPermissionRequestMetadata {
        const message = { schemaVersion: "", snapToken: "", onlyPermission: false, depth: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionSubjectPermissionRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionSubjectPermissionRequestMetadata): PermissionSubjectPermissionRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                case /* string snap_token = 2 [json_name = "snap_token"];*/ 2:
                    message.snapToken = reader.string();
                    break;
                case /* bool only_permission = 3 [json_name = "only_permission"];*/ 3:
                    message.onlyPermission = reader.bool();
                    break;
                case /* int32 depth */ 4:
                    message.depth = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionSubjectPermissionRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        /* string snap_token = 2 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.snapToken);
        /* bool only_permission = 3 [json_name = "only_permission"]; */
        if (message.onlyPermission !== false)
            writer.tag(3, WireType.Varint).bool(message.onlyPermission);
        /* int32 depth = 4; */
        if (message.depth !== 0)
            writer.tag(4, WireType.Varint).int32(message.depth);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionSubjectPermissionRequestMetadata
 */
export const PermissionSubjectPermissionRequestMetadata = new PermissionSubjectPermissionRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionSubjectPermissionResponse$Type extends MessageType<PermissionSubjectPermissionResponse> {
    constructor() {
        super("base.v1.PermissionSubjectPermissionResponse", [
            { no: 1, name: "results", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "enum", T: () => ["base.v1.CheckResult", CheckResult, "CHECK_RESULT_"] } }
        ]);
    }
    create(value?: PartialMessage<PermissionSubjectPermissionResponse>): PermissionSubjectPermissionResponse {
        const message = { results: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PermissionSubjectPermissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionSubjectPermissionResponse): PermissionSubjectPermissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, base.v1.CheckResult> results */ 1:
                    this.binaryReadMap1(message.results, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: PermissionSubjectPermissionResponse["results"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PermissionSubjectPermissionResponse["results"] | undefined, val: PermissionSubjectPermissionResponse["results"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.PermissionSubjectPermissionResponse.results");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: PermissionSubjectPermissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, base.v1.CheckResult> results = 1; */
        for (let k of Object.keys(message.results))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.results[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.PermissionSubjectPermissionResponse
 */
export const PermissionSubjectPermissionResponse = new PermissionSubjectPermissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchRequest$Type extends MessageType<WatchRequest> {
    constructor() {
        super("base.v1.WatchRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)." } } }
        ]);
    }
    create(value?: PartialMessage<WatchRequest>): WatchRequest {
        const message = { tenantId: "", snapToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WatchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchRequest): WatchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* string snap_token = 2 [json_name = "snap_token"];*/ 2:
                    message.snapToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* string snap_token = 2 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.snapToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.WatchRequest
 */
export const WatchRequest = new WatchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchResponse$Type extends MessageType<WatchResponse> {
    constructor() {
        super("base.v1.WatchResponse", [
            { no: 1, name: "changes", kind: "message", T: () => DataChanges }
        ]);
    }
    create(value?: PartialMessage<WatchResponse>): WatchResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WatchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchResponse): WatchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.DataChanges changes */ 1:
                    message.changes = DataChanges.internalBinaryRead(reader, reader.uint32(), options, message.changes);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.DataChanges changes = 1; */
        if (message.changes)
            DataChanges.internalBinaryWrite(message.changes, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.WatchResponse
 */
export const WatchResponse = new WatchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaWriteRequest$Type extends MessageType<SchemaWriteRequest> {
    constructor() {
        super("base.v1.SchemaWriteRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "schema", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SchemaWriteRequest>): SchemaWriteRequest {
        const message = { tenantId: "", schema: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaWriteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaWriteRequest): SchemaWriteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* string schema */ 2:
                    message.schema = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaWriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* string schema = 2; */
        if (message.schema !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.schema);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaWriteRequest
 */
export const SchemaWriteRequest = new SchemaWriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaWriteResponse$Type extends MessageType<SchemaWriteResponse> {
    constructor() {
        super("base.v1.SchemaWriteResponse", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SchemaWriteResponse>): SchemaWriteResponse {
        const message = { schemaVersion: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaWriteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaWriteResponse): SchemaWriteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaWriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaWriteResponse
 */
export const SchemaWriteResponse = new SchemaWriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaPartialWriteRequest$Type extends MessageType<SchemaPartialWriteRequest> {
    constructor() {
        super("base.v1.SchemaPartialWriteRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } } } },
            { no: 2, name: "metadata", kind: "message", T: () => SchemaPartialWriteRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "partials", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Partials } }
        ]);
    }
    create(value?: PartialMessage<SchemaPartialWriteRequest>): SchemaPartialWriteRequest {
        const message = { tenantId: "", partials: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaPartialWriteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaPartialWriteRequest): SchemaPartialWriteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.SchemaPartialWriteRequestMetadata metadata */ 2:
                    message.metadata = SchemaPartialWriteRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* map<string, base.v1.Partials> partials */ 3:
                    this.binaryReadMap3(message.partials, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: SchemaPartialWriteRequest["partials"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof SchemaPartialWriteRequest["partials"] | undefined, val: SchemaPartialWriteRequest["partials"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Partials.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.SchemaPartialWriteRequest.partials");
            }
        }
        map[key ?? ""] = val ?? Partials.create();
    }
    internalBinaryWrite(message: SchemaPartialWriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.SchemaPartialWriteRequestMetadata metadata = 2; */
        if (message.metadata)
            SchemaPartialWriteRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<string, base.v1.Partials> partials = 3; */
        for (let k of Object.keys(message.partials)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Partials.internalBinaryWrite(message.partials[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaPartialWriteRequest
 */
export const SchemaPartialWriteRequest = new SchemaPartialWriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaPartialWriteRequestMetadata$Type extends MessageType<SchemaPartialWriteRequestMetadata> {
    constructor() {
        super("base.v1.SchemaPartialWriteRequestMetadata", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SchemaPartialWriteRequestMetadata>): SchemaPartialWriteRequestMetadata {
        const message = { schemaVersion: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaPartialWriteRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaPartialWriteRequestMetadata): SchemaPartialWriteRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaPartialWriteRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaPartialWriteRequestMetadata
 */
export const SchemaPartialWriteRequestMetadata = new SchemaPartialWriteRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaPartialWriteResponse$Type extends MessageType<SchemaPartialWriteResponse> {
    constructor() {
        super("base.v1.SchemaPartialWriteResponse", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SchemaPartialWriteResponse>): SchemaPartialWriteResponse {
        const message = { schemaVersion: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaPartialWriteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaPartialWriteResponse): SchemaPartialWriteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaPartialWriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaPartialWriteResponse
 */
export const SchemaPartialWriteResponse = new SchemaPartialWriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaReadRequest$Type extends MessageType<SchemaReadRequest> {
    constructor() {
        super("base.v1.SchemaReadRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => SchemaReadRequestMetadata, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<SchemaReadRequest>): SchemaReadRequest {
        const message = { tenantId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaReadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaReadRequest): SchemaReadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.SchemaReadRequestMetadata metadata */ 2:
                    message.metadata = SchemaReadRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaReadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.SchemaReadRequestMetadata metadata = 2; */
        if (message.metadata)
            SchemaReadRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaReadRequest
 */
export const SchemaReadRequest = new SchemaReadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaReadRequestMetadata$Type extends MessageType<SchemaReadRequestMetadata> {
    constructor() {
        super("base.v1.SchemaReadRequestMetadata", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SchemaReadRequestMetadata>): SchemaReadRequestMetadata {
        const message = { schemaVersion: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaReadRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaReadRequestMetadata): SchemaReadRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaReadRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaReadRequestMetadata
 */
export const SchemaReadRequestMetadata = new SchemaReadRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaReadResponse$Type extends MessageType<SchemaReadResponse> {
    constructor() {
        super("base.v1.SchemaReadResponse", [
            { no: 1, name: "schema", kind: "message", T: () => SchemaDefinition }
        ]);
    }
    create(value?: PartialMessage<SchemaReadResponse>): SchemaReadResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaReadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaReadResponse): SchemaReadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.SchemaDefinition schema */ 1:
                    message.schema = SchemaDefinition.internalBinaryRead(reader, reader.uint32(), options, message.schema);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaReadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.SchemaDefinition schema = 1; */
        if (message.schema)
            SchemaDefinition.internalBinaryWrite(message.schema, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaReadResponse
 */
export const SchemaReadResponse = new SchemaReadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaListRequest$Type extends MessageType<SchemaListRequest> {
    constructor() {
        super("base.v1.SchemaListRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "page_size", kind: "scalar", jsonName: "page_size", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 1, ignoreEmpty: true } } } },
            { no: 3, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<SchemaListRequest>): SchemaListRequest {
        const message = { tenantId: "", pageSize: 0, continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaListRequest): SchemaListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* uint32 page_size = 2 [json_name = "page_size"];*/ 2:
                    message.pageSize = reader.uint32();
                    break;
                case /* string continuous_token = 3 [json_name = "continuous_token"];*/ 3:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* uint32 page_size = 2 [json_name = "page_size"]; */
        if (message.pageSize !== 0)
            writer.tag(2, WireType.Varint).uint32(message.pageSize);
        /* string continuous_token = 3 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaListRequest
 */
export const SchemaListRequest = new SchemaListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaListResponse$Type extends MessageType<SchemaListResponse> {
    constructor() {
        super("base.v1.SchemaListResponse", [
            { no: 1, name: "head", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "schemas", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SchemaList },
            { no: 3, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SchemaListResponse>): SchemaListResponse {
        const message = { head: "", schemas: [], continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaListResponse): SchemaListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string head */ 1:
                    message.head = reader.string();
                    break;
                case /* repeated base.v1.SchemaList schemas */ 2:
                    message.schemas.push(SchemaList.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string continuous_token = 3 [json_name = "continuous_token"];*/ 3:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string head = 1; */
        if (message.head !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.head);
        /* repeated base.v1.SchemaList schemas = 2; */
        for (let i = 0; i < message.schemas.length; i++)
            SchemaList.internalBinaryWrite(message.schemas[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string continuous_token = 3 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaListResponse
 */
export const SchemaListResponse = new SchemaListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SchemaList$Type extends MessageType<SchemaList> {
    constructor() {
        super("base.v1.SchemaList", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "created_at", kind: "scalar", jsonName: "created_at", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SchemaList>): SchemaList {
        const message = { version: "", createdAt: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SchemaList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SchemaList): SchemaList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* string created_at = 2 [json_name = "created_at"];*/ 2:
                    message.createdAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SchemaList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* string created_at = 2 [json_name = "created_at"]; */
        if (message.createdAt !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.createdAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.SchemaList
 */
export const SchemaList = new SchemaList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataWriteRequest$Type extends MessageType<DataWriteRequest> {
    constructor() {
        super("base.v1.DataWriteRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => DataWriteRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "tuples", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tuple, options: { "validate.rules": { repeated: { minItems: "0", items: { message: { required: true } } } } } },
            { no: 4, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Attribute, options: { "validate.rules": { repeated: { minItems: "0", items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<DataWriteRequest>): DataWriteRequest {
        const message = { tenantId: "", tuples: [], attributes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DataWriteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataWriteRequest): DataWriteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.DataWriteRequestMetadata metadata */ 2:
                    message.metadata = DataWriteRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* repeated base.v1.Tuple tuples */ 3:
                    message.tuples.push(Tuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated base.v1.Attribute attributes */ 4:
                    message.attributes.push(Attribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataWriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.DataWriteRequestMetadata metadata = 2; */
        if (message.metadata)
            DataWriteRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated base.v1.Tuple tuples = 3; */
        for (let i = 0; i < message.tuples.length; i++)
            Tuple.internalBinaryWrite(message.tuples[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated base.v1.Attribute attributes = 4; */
        for (let i = 0; i < message.attributes.length; i++)
            Attribute.internalBinaryWrite(message.attributes[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.DataWriteRequest
 */
export const DataWriteRequest = new DataWriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataWriteRequestMetadata$Type extends MessageType<DataWriteRequestMetadata> {
    constructor() {
        super("base.v1.DataWriteRequestMetadata", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DataWriteRequestMetadata>): DataWriteRequestMetadata {
        const message = { schemaVersion: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DataWriteRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataWriteRequestMetadata): DataWriteRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataWriteRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.DataWriteRequestMetadata
 */
export const DataWriteRequestMetadata = new DataWriteRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataWriteResponse$Type extends MessageType<DataWriteResponse> {
    constructor() {
        super("base.v1.DataWriteResponse", [
            { no: 1, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)." } } }
        ]);
    }
    create(value?: PartialMessage<DataWriteResponse>): DataWriteResponse {
        const message = { snapToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DataWriteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataWriteResponse): DataWriteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string snap_token = 1 [json_name = "snap_token"];*/ 1:
                    message.snapToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataWriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string snap_token = 1 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snapToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.DataWriteResponse
 */
export const DataWriteResponse = new DataWriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipWriteRequest$Type extends MessageType<RelationshipWriteRequest> {
    constructor() {
        super("base.v1.RelationshipWriteRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => RelationshipWriteRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "tuples", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tuple, options: { "validate.rules": { repeated: { minItems: "1", items: { message: { required: true } } } } } }
        ]);
    }
    create(value?: PartialMessage<RelationshipWriteRequest>): RelationshipWriteRequest {
        const message = { tenantId: "", tuples: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationshipWriteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationshipWriteRequest): RelationshipWriteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.RelationshipWriteRequestMetadata metadata */ 2:
                    message.metadata = RelationshipWriteRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* repeated base.v1.Tuple tuples */ 3:
                    message.tuples.push(Tuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationshipWriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.RelationshipWriteRequestMetadata metadata = 2; */
        if (message.metadata)
            RelationshipWriteRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated base.v1.Tuple tuples = 3; */
        for (let i = 0; i < message.tuples.length; i++)
            Tuple.internalBinaryWrite(message.tuples[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RelationshipWriteRequest
 */
export const RelationshipWriteRequest = new RelationshipWriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipWriteRequestMetadata$Type extends MessageType<RelationshipWriteRequestMetadata> {
    constructor() {
        super("base.v1.RelationshipWriteRequestMetadata", [
            { no: 1, name: "schema_version", kind: "scalar", jsonName: "schema_version", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RelationshipWriteRequestMetadata>): RelationshipWriteRequestMetadata {
        const message = { schemaVersion: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationshipWriteRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationshipWriteRequestMetadata): RelationshipWriteRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string schema_version = 1 [json_name = "schema_version"];*/ 1:
                    message.schemaVersion = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationshipWriteRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string schema_version = 1 [json_name = "schema_version"]; */
        if (message.schemaVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.schemaVersion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RelationshipWriteRequestMetadata
 */
export const RelationshipWriteRequestMetadata = new RelationshipWriteRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipWriteResponse$Type extends MessageType<RelationshipWriteResponse> {
    constructor() {
        super("base.v1.RelationshipWriteResponse", [
            { no: 1, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)" } } }
        ]);
    }
    create(value?: PartialMessage<RelationshipWriteResponse>): RelationshipWriteResponse {
        const message = { snapToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationshipWriteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationshipWriteResponse): RelationshipWriteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string snap_token = 1 [json_name = "snap_token"];*/ 1:
                    message.snapToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationshipWriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string snap_token = 1 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snapToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RelationshipWriteResponse
 */
export const RelationshipWriteResponse = new RelationshipWriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipReadRequest$Type extends MessageType<RelationshipReadRequest> {
    constructor() {
        super("base.v1.RelationshipReadRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => RelationshipReadRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "filter", kind: "message", T: () => TupleFilter, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "page_size", kind: "scalar", jsonName: "page_size", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 1, ignoreEmpty: true } } } },
            { no: 5, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<RelationshipReadRequest>): RelationshipReadRequest {
        const message = { tenantId: "", pageSize: 0, continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationshipReadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationshipReadRequest): RelationshipReadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.RelationshipReadRequestMetadata metadata */ 2:
                    message.metadata = RelationshipReadRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* base.v1.TupleFilter filter */ 3:
                    message.filter = TupleFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* uint32 page_size = 4 [json_name = "page_size"];*/ 4:
                    message.pageSize = reader.uint32();
                    break;
                case /* string continuous_token = 5 [json_name = "continuous_token"];*/ 5:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationshipReadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.RelationshipReadRequestMetadata metadata = 2; */
        if (message.metadata)
            RelationshipReadRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.TupleFilter filter = 3; */
        if (message.filter)
            TupleFilter.internalBinaryWrite(message.filter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 page_size = 4 [json_name = "page_size"]; */
        if (message.pageSize !== 0)
            writer.tag(4, WireType.Varint).uint32(message.pageSize);
        /* string continuous_token = 5 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RelationshipReadRequest
 */
export const RelationshipReadRequest = new RelationshipReadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipReadRequestMetadata$Type extends MessageType<RelationshipReadRequestMetadata> {
    constructor() {
        super("base.v1.RelationshipReadRequestMetadata", [
            { no: 1, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)" } } }
        ]);
    }
    create(value?: PartialMessage<RelationshipReadRequestMetadata>): RelationshipReadRequestMetadata {
        const message = { snapToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationshipReadRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationshipReadRequestMetadata): RelationshipReadRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string snap_token = 1 [json_name = "snap_token"];*/ 1:
                    message.snapToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationshipReadRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string snap_token = 1 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snapToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RelationshipReadRequestMetadata
 */
export const RelationshipReadRequestMetadata = new RelationshipReadRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipReadResponse$Type extends MessageType<RelationshipReadResponse> {
    constructor() {
        super("base.v1.RelationshipReadResponse", [
            { no: 1, name: "tuples", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tuple },
            { no: 2, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RelationshipReadResponse>): RelationshipReadResponse {
        const message = { tuples: [], continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationshipReadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationshipReadResponse): RelationshipReadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated base.v1.Tuple tuples */ 1:
                    message.tuples.push(Tuple.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string continuous_token = 2 [json_name = "continuous_token"];*/ 2:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationshipReadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated base.v1.Tuple tuples = 1; */
        for (let i = 0; i < message.tuples.length; i++)
            Tuple.internalBinaryWrite(message.tuples[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string continuous_token = 2 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RelationshipReadResponse
 */
export const RelationshipReadResponse = new RelationshipReadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeReadRequest$Type extends MessageType<AttributeReadRequest> {
    constructor() {
        super("base.v1.AttributeReadRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "metadata", kind: "message", T: () => AttributeReadRequestMetadata, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "filter", kind: "message", T: () => AttributeFilter, options: { "validate.rules": { message: { required: true } } } },
            { no: 4, name: "page_size", kind: "scalar", jsonName: "page_size", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 1, ignoreEmpty: true } } } },
            { no: 5, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<AttributeReadRequest>): AttributeReadRequest {
        const message = { tenantId: "", pageSize: 0, continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttributeReadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeReadRequest): AttributeReadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.AttributeReadRequestMetadata metadata */ 2:
                    message.metadata = AttributeReadRequestMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                case /* base.v1.AttributeFilter filter */ 3:
                    message.filter = AttributeFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* uint32 page_size = 4 [json_name = "page_size"];*/ 4:
                    message.pageSize = reader.uint32();
                    break;
                case /* string continuous_token = 5 [json_name = "continuous_token"];*/ 5:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeReadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.AttributeReadRequestMetadata metadata = 2; */
        if (message.metadata)
            AttributeReadRequestMetadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.AttributeFilter filter = 3; */
        if (message.filter)
            AttributeFilter.internalBinaryWrite(message.filter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 page_size = 4 [json_name = "page_size"]; */
        if (message.pageSize !== 0)
            writer.tag(4, WireType.Varint).uint32(message.pageSize);
        /* string continuous_token = 5 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.AttributeReadRequest
 */
export const AttributeReadRequest = new AttributeReadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeReadRequestMetadata$Type extends MessageType<AttributeReadRequestMetadata> {
    constructor() {
        super("base.v1.AttributeReadRequestMetadata", [
            { no: 1, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)" } } }
        ]);
    }
    create(value?: PartialMessage<AttributeReadRequestMetadata>): AttributeReadRequestMetadata {
        const message = { snapToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttributeReadRequestMetadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeReadRequestMetadata): AttributeReadRequestMetadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string snap_token = 1 [json_name = "snap_token"];*/ 1:
                    message.snapToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeReadRequestMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string snap_token = 1 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snapToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.AttributeReadRequestMetadata
 */
export const AttributeReadRequestMetadata = new AttributeReadRequestMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AttributeReadResponse$Type extends MessageType<AttributeReadResponse> {
    constructor() {
        super("base.v1.AttributeReadResponse", [
            { no: 1, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Attribute },
            { no: 2, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AttributeReadResponse>): AttributeReadResponse {
        const message = { attributes: [], continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AttributeReadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AttributeReadResponse): AttributeReadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated base.v1.Attribute attributes */ 1:
                    message.attributes.push(Attribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string continuous_token = 2 [json_name = "continuous_token"];*/ 2:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AttributeReadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated base.v1.Attribute attributes = 1; */
        for (let i = 0; i < message.attributes.length; i++)
            Attribute.internalBinaryWrite(message.attributes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string continuous_token = 2 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.AttributeReadResponse
 */
export const AttributeReadResponse = new AttributeReadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataDeleteRequest$Type extends MessageType<DataDeleteRequest> {
    constructor() {
        super("base.v1.DataDeleteRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "tuple_filter", kind: "message", jsonName: "tuple_filter", T: () => TupleFilter, options: { "validate.rules": { message: { required: true } } } },
            { no: 3, name: "attribute_filter", kind: "message", jsonName: "attribute_filter", T: () => AttributeFilter, options: { "validate.rules": { message: { required: true } } } }
        ]);
    }
    create(value?: PartialMessage<DataDeleteRequest>): DataDeleteRequest {
        const message = { tenantId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DataDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataDeleteRequest): DataDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.TupleFilter tuple_filter = 2 [json_name = "tuple_filter"];*/ 2:
                    message.tupleFilter = TupleFilter.internalBinaryRead(reader, reader.uint32(), options, message.tupleFilter);
                    break;
                case /* base.v1.AttributeFilter attribute_filter = 3 [json_name = "attribute_filter"];*/ 3:
                    message.attributeFilter = AttributeFilter.internalBinaryRead(reader, reader.uint32(), options, message.attributeFilter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.TupleFilter tuple_filter = 2 [json_name = "tuple_filter"]; */
        if (message.tupleFilter)
            TupleFilter.internalBinaryWrite(message.tupleFilter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* base.v1.AttributeFilter attribute_filter = 3 [json_name = "attribute_filter"]; */
        if (message.attributeFilter)
            AttributeFilter.internalBinaryWrite(message.attributeFilter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.DataDeleteRequest
 */
export const DataDeleteRequest = new DataDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataDeleteResponse$Type extends MessageType<DataDeleteResponse> {
    constructor() {
        super("base.v1.DataDeleteResponse", [
            { no: 1, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)" } } }
        ]);
    }
    create(value?: PartialMessage<DataDeleteResponse>): DataDeleteResponse {
        const message = { snapToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DataDeleteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataDeleteResponse): DataDeleteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string snap_token = 1 [json_name = "snap_token"];*/ 1:
                    message.snapToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataDeleteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string snap_token = 1 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snapToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.DataDeleteResponse
 */
export const DataDeleteResponse = new DataDeleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipDeleteRequest$Type extends MessageType<RelationshipDeleteRequest> {
    constructor() {
        super("base.v1.RelationshipDeleteRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "filter", kind: "message", T: () => TupleFilter }
        ]);
    }
    create(value?: PartialMessage<RelationshipDeleteRequest>): RelationshipDeleteRequest {
        const message = { tenantId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationshipDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationshipDeleteRequest): RelationshipDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* base.v1.TupleFilter filter */ 2:
                    message.filter = TupleFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationshipDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* base.v1.TupleFilter filter = 2; */
        if (message.filter)
            TupleFilter.internalBinaryWrite(message.filter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RelationshipDeleteRequest
 */
export const RelationshipDeleteRequest = new RelationshipDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelationshipDeleteResponse$Type extends MessageType<RelationshipDeleteResponse> {
    constructor() {
        super("base.v1.RelationshipDeleteResponse", [
            { no: 1, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)" } } }
        ]);
    }
    create(value?: PartialMessage<RelationshipDeleteResponse>): RelationshipDeleteResponse {
        const message = { snapToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelationshipDeleteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelationshipDeleteResponse): RelationshipDeleteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string snap_token = 1 [json_name = "snap_token"];*/ 1:
                    message.snapToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelationshipDeleteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string snap_token = 1 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snapToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.RelationshipDeleteResponse
 */
export const RelationshipDeleteResponse = new RelationshipDeleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BundleRunRequest$Type extends MessageType<BundleRunRequest> {
    constructor() {
        super("base.v1.BundleRunRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "arguments", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<BundleRunRequest>): BundleRunRequest {
        const message = { tenantId: "", name: "", arguments: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BundleRunRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BundleRunRequest): BundleRunRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* map<string, string> arguments */ 3:
                    this.binaryReadMap3(message.arguments, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: BundleRunRequest["arguments"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof BundleRunRequest["arguments"] | undefined, val: BundleRunRequest["arguments"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field base.v1.BundleRunRequest.arguments");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: BundleRunRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* map<string, string> arguments = 3; */
        for (let k of Object.keys(message.arguments))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.arguments[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.BundleRunRequest
 */
export const BundleRunRequest = new BundleRunRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BundleRunResponse$Type extends MessageType<BundleRunResponse> {
    constructor() {
        super("base.v1.BundleRunResponse", [
            { no: 1, name: "snap_token", kind: "scalar", jsonName: "snap_token", T: 9 /*ScalarType.STRING*/, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "The snap token to avoid stale cache, see more details on [Snap Tokens](../../operations/snap-tokens)" } } }
        ]);
    }
    create(value?: PartialMessage<BundleRunResponse>): BundleRunResponse {
        const message = { snapToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BundleRunResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BundleRunResponse): BundleRunResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string snap_token = 1 [json_name = "snap_token"];*/ 1:
                    message.snapToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BundleRunResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string snap_token = 1 [json_name = "snap_token"]; */
        if (message.snapToken !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.snapToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.BundleRunResponse
 */
export const BundleRunResponse = new BundleRunResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BundleWriteRequest$Type extends MessageType<BundleWriteRequest> {
    constructor() {
        super("base.v1.BundleWriteRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "bundles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DataBundle }
        ]);
    }
    create(value?: PartialMessage<BundleWriteRequest>): BundleWriteRequest {
        const message = { tenantId: "", bundles: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BundleWriteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BundleWriteRequest): BundleWriteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* repeated base.v1.DataBundle bundles */ 2:
                    message.bundles.push(DataBundle.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BundleWriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* repeated base.v1.DataBundle bundles = 2; */
        for (let i = 0; i < message.bundles.length; i++)
            DataBundle.internalBinaryWrite(message.bundles[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.BundleWriteRequest
 */
export const BundleWriteRequest = new BundleWriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BundleWriteResponse$Type extends MessageType<BundleWriteResponse> {
    constructor() {
        super("base.v1.BundleWriteResponse", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BundleWriteResponse>): BundleWriteResponse {
        const message = { names: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BundleWriteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BundleWriteResponse): BundleWriteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BundleWriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.BundleWriteResponse
 */
export const BundleWriteResponse = new BundleWriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BundleReadRequest$Type extends MessageType<BundleReadRequest> {
    constructor() {
        super("base.v1.BundleReadRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BundleReadRequest>): BundleReadRequest {
        const message = { tenantId: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BundleReadRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BundleReadRequest): BundleReadRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BundleReadRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.BundleReadRequest
 */
export const BundleReadRequest = new BundleReadRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BundleReadResponse$Type extends MessageType<BundleReadResponse> {
    constructor() {
        super("base.v1.BundleReadResponse", [
            { no: 1, name: "bundle", kind: "message", T: () => DataBundle }
        ]);
    }
    create(value?: PartialMessage<BundleReadResponse>): BundleReadResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BundleReadResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BundleReadResponse): BundleReadResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.DataBundle bundle */ 1:
                    message.bundle = DataBundle.internalBinaryRead(reader, reader.uint32(), options, message.bundle);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BundleReadResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.DataBundle bundle = 1; */
        if (message.bundle)
            DataBundle.internalBinaryWrite(message.bundle, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.BundleReadResponse
 */
export const BundleReadResponse = new BundleReadResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BundleDeleteRequest$Type extends MessageType<BundleDeleteRequest> {
    constructor() {
        super("base.v1.BundleDeleteRequest", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "128", pattern: "^([a-zA-Z0-9_\\-@\\.:+]{1,128}|\\*)$", ignoreEmpty: false } }, "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field": { description: "Identifier of the tenant, if you are not using multi-tenancy (have only one tenant) use pre-inserted tenant <code>t1</code> for this field. Required, and must match the pattern \\\u201C[a-zA-Z0-9-,]+\\\u201C, max 64 bytes." } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BundleDeleteRequest>): BundleDeleteRequest {
        const message = { tenantId: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BundleDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BundleDeleteRequest): BundleDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BundleDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.BundleDeleteRequest
 */
export const BundleDeleteRequest = new BundleDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BundleDeleteResponse$Type extends MessageType<BundleDeleteResponse> {
    constructor() {
        super("base.v1.BundleDeleteResponse", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BundleDeleteResponse>): BundleDeleteResponse {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BundleDeleteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BundleDeleteResponse): BundleDeleteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BundleDeleteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.BundleDeleteResponse
 */
export const BundleDeleteResponse = new BundleDeleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TenantCreateRequest$Type extends MessageType<TenantCreateRequest> {
    constructor() {
        super("base.v1.TenantCreateRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", pattern: "[a-zA-Z0-9-,]+", ignoreEmpty: false } } } },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { maxBytes: "64", ignoreEmpty: false } } } }
        ]);
    }
    create(value?: PartialMessage<TenantCreateRequest>): TenantCreateRequest {
        const message = { id: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TenantCreateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TenantCreateRequest): TenantCreateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TenantCreateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.TenantCreateRequest
 */
export const TenantCreateRequest = new TenantCreateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TenantCreateResponse$Type extends MessageType<TenantCreateResponse> {
    constructor() {
        super("base.v1.TenantCreateResponse", [
            { no: 1, name: "tenant", kind: "message", T: () => Tenant }
        ]);
    }
    create(value?: PartialMessage<TenantCreateResponse>): TenantCreateResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TenantCreateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TenantCreateResponse): TenantCreateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* base.v1.Tenant tenant */ 1:
                    message.tenant = Tenant.internalBinaryRead(reader, reader.uint32(), options, message.tenant);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TenantCreateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* base.v1.Tenant tenant = 1; */
        if (message.tenant)
            Tenant.internalBinaryWrite(message.tenant, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.TenantCreateResponse
 */
export const TenantCreateResponse = new TenantCreateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TenantDeleteRequest$Type extends MessageType<TenantDeleteRequest> {
    constructor() {
        super("base.v1.TenantDeleteRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { ignoreEmpty: false } } } }
        ]);
    }
    create(value?: PartialMessage<TenantDeleteRequest>): TenantDeleteRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TenantDeleteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TenantDeleteRequest): TenantDeleteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TenantDeleteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.TenantDeleteRequest
 */
export const TenantDeleteRequest = new TenantDeleteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TenantDeleteResponse$Type extends MessageType<TenantDeleteResponse> {
    constructor() {
        super("base.v1.TenantDeleteResponse", [
            { no: 1, name: "tenant_id", kind: "scalar", jsonName: "tenant_id", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TenantDeleteResponse>): TenantDeleteResponse {
        const message = { tenantId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TenantDeleteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TenantDeleteResponse): TenantDeleteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tenant_id = 1 [json_name = "tenant_id"];*/ 1:
                    message.tenantId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TenantDeleteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tenant_id = 1 [json_name = "tenant_id"]; */
        if (message.tenantId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tenantId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.TenantDeleteResponse
 */
export const TenantDeleteResponse = new TenantDeleteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TenantListRequest$Type extends MessageType<TenantListRequest> {
    constructor() {
        super("base.v1.TenantListRequest", [
            { no: 1, name: "page_size", kind: "scalar", jsonName: "page_size", T: 13 /*ScalarType.UINT32*/, options: { "validate.rules": { uint32: { gte: 1, ignoreEmpty: true } } } },
            { no: 2, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/, options: { "validate.rules": { string: { ignoreEmpty: true } } } }
        ]);
    }
    create(value?: PartialMessage<TenantListRequest>): TenantListRequest {
        const message = { pageSize: 0, continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TenantListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TenantListRequest): TenantListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 page_size = 1 [json_name = "page_size"];*/ 1:
                    message.pageSize = reader.uint32();
                    break;
                case /* string continuous_token = 2 [json_name = "continuous_token"];*/ 2:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TenantListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 page_size = 1 [json_name = "page_size"]; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).uint32(message.pageSize);
        /* string continuous_token = 2 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.TenantListRequest
 */
export const TenantListRequest = new TenantListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TenantListResponse$Type extends MessageType<TenantListResponse> {
    constructor() {
        super("base.v1.TenantListResponse", [
            { no: 1, name: "tenants", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tenant },
            { no: 2, name: "continuous_token", kind: "scalar", jsonName: "continuous_token", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TenantListResponse>): TenantListResponse {
        const message = { tenants: [], continuousToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TenantListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TenantListResponse): TenantListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated base.v1.Tenant tenants */ 1:
                    message.tenants.push(Tenant.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string continuous_token = 2 [json_name = "continuous_token"];*/ 2:
                    message.continuousToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TenantListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated base.v1.Tenant tenants = 1; */
        for (let i = 0; i < message.tenants.length; i++)
            Tenant.internalBinaryWrite(message.tenants[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string continuous_token = 2 [json_name = "continuous_token"]; */
        if (message.continuousToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.continuousToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message base.v1.TenantListResponse
 */
export const TenantListResponse = new TenantListResponse$Type();
/**
 * @generated ServiceType for protobuf service base.v1.Permission
 */
export const Permission = new ServiceType("base.v1.Permission", [
    { name: "Check", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Permission"], summary: "check api", operationId: "permissions.check", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "cr, err := client.Permission.Check(context.Background(), &v1.PermissionCheckRequest {\n    TenantId: \"t1\",\n    Metadata: &v1.PermissionCheckRequestMetadata {\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n        Depth: 20,\n    },\n    Entity: &v1.Entity {\n        Type: \"repository\",\n        Id: \"1\",\n    },\n    Permission: \"edit\",\n    Subject: &v1.Subject {\n        Type: \"user\",\n        Id: \"1\",\n    },\n})\nif cr.Can == v1.PermissionCheckResponse_Result_RESULT_ALLOWED {\n    // RESULT_ALLOWED\n} else {\n    // RESULT_DENIED\n}" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.permission.check({\n    tenantId: \"t1\", \n    metadata: {\n        snapToken: \"\",\n        schemaVersion: \"\",\n        depth: 20\n    },\n    entity: {\n        type: \"repository\",\n        id: \"1\"\n    },\n    permission: \"edit\",\n    subject: {\n        type: \"user\",\n        id: \"1\"\n    }\n}).then((response) => {\n    if (response.can === PermissionCheckResponse_Result.RESULT_ALLOWED) {\n        console.log(\"RESULT_ALLOWED\")\n    } else {\n        console.log(\"RESULT_DENIED\")\n    }\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/check' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"metadata\": {\n    \"snap_token\": \"\",\n    \"schema_version\": \"\",\n    \"depth\": 20\n  },\n  \"entity\": {\n    \"type\": \"repository\",\n    \"id\": \"1\"\n  },\n  \"permission\": \"edit\",\n  \"subject\": {\n    \"type\": \"user\",\n    \"id\": \"1\",\n    \"relation\": \"\"\n  }\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/permissions/check", body: "*" } }, I: PermissionCheckRequest, O: PermissionCheckResponse },
    { name: "Expand", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Permission"], summary: "expand api", operationId: "permissions.expand", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "cr, err := client.Permission.Expand(context.Background(), &v1.PermissionExpandRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.PermissionExpandRequestMetadata{\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n    },\n    Entity: &v1.Entity{\n        Type: \"repository\",\n        Id: \"1\",\n    },\n    Permission: \"push\",\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.permission.expand({\n    tenantId: \"t1\",\n    metadata: {\n        snapToken: \"\",\n        schemaVersion: \"\"\n    },\n    entity: {\n        type: \"repository\",\n        id: \"1\"\n    },\n    permission: \"push\",\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/expand' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"metadata\": {\n    \"schema_version\": \"\",\n    \"snap_token\": \"\"\n  },\n  \"entity\": {\n    \"type\": \"repository\",\n    \"id\": \"1\"\n  },\n  \"permission\": \"push\"\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/permissions/expand", body: "*" } }, I: PermissionExpandRequest, O: PermissionExpandResponse },
    { name: "LookupEntity", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Permission"], summary: "lookup entity", operationId: "permissions.lookupEntity", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "cr, err := client.Permission.LookupEntity(context.Background(), &v1.PermissionLookupEntityRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.PermissionLookupEntityRequestMetadata{\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n        Depth: 20,\n    },\n    EntityType: \"document\",\n    Permission: \"edit\",\n    Subject: &v1.Subject{\n        Type: \"user\",\n        Id: \"1\",\n    }\n    PageSize: 20,\n    ContinuousToken: \"\",\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.permission.lookupEntity({\n    tenantId: \"t1\",\n    metadata: {\n        snapToken: \"\",\n        schemaVersion: \"\",\n        depth: 20\n    },\n    entity_type: \"document\",\n    permission: \"edit\",\n    subject: {\n        type: \"user\",\n        id: \"1\"\n    },\n    page_size: 20,\n    continuous_token: \"\"\n}).then((response) => {\n    console.log(response.entity_ids)\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/lookup-entity' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"metadata\":{\n    \"snap_token\": \"\",\n    \"schema_version\": \"\",\n    \"depth\": 20\n  },\n  \"entity_type\": \"document\",\n  \"permission\": \"edit\",\n  \"subject\": {\n    \"type\":\"user\",\n    \"id\":\"1\"\n  },\n  \"page_size\": 20,\n  \"continuous_token\": \"\",\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/permissions/lookup-entity", body: "*" } }, I: PermissionLookupEntityRequest, O: PermissionLookupEntityResponse },
    { name: "LookupEntityStream", serverStreaming: true, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Permission"], summary: "lookup entity stream", operationId: "permissions.lookupEntityStream", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "str, err := client.Permission.LookupEntityStream(context.Background(), &v1.PermissionLookupEntityRequest{\n    Metadata: &v1.PermissionLookupEntityRequestMetadata{\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n        Depth: 50,\n    },\n    EntityType: \"document\",\n    Permission: \"view\",\n    Subject: &v1.Subject{\n        Type: \"user\",\n        Id: \"1\",\n    },\n    PageSize: 20,\n    ContinuousToken: \"\",\n})\n\n// handle stream response\nfor {\n    res, err := str.Recv()\n\n    if err == io.EOF {\n        break\n    }\n\n    // res.EntityId\n}" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "const permify = require(\"@permify/permify-node\");\nconst {PermissionLookupEntityStreamResponse} = require(\"@permify/permify-node/dist/src/grpc/generated/base/v1/service\");\n\nfunction main() {\n    const client = new permify.grpc.newClient({\n        endpoint: \"localhost:3478\",\n    });\n\n    let res = client.permission.lookupEntityStream({\n        metadata: {\n            snapToken: \"\",\n            schemaVersion: \"\",\n            depth: 20\n        },\n        entityType: \"document\",\n        permission: \"view\",\n        subject: {\n            type: \"user\",\n            id: \"1\"\n        },\n        page_size: 20,\n        continuous_token: \"\"\n    });\n\n    handle(res);\n}\n\nasync function handle(res: AsyncIterable<PermissionLookupEntityStreamResponse>) {\n    for await (const response of res) {\n        // response.entityId\n    }\n}" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/permissions/lookup-entity-stream", body: "*" } }, I: PermissionLookupEntityRequest, O: PermissionLookupEntityStreamResponse },
    { name: "LookupSubject", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Permission"], summary: "lookup-subject", operationId: "permissions.lookupSubject", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "cr, err := client.Permission.LookupSubject(context.Background(), &v1.PermissionLookupSubjectRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.PermissionLookupSubjectRequestMetadata{\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n        Depth: 20,\n    },\n    Entity: &v1.Entity{\n        Type: \"document\",\n        Id: \"1\",\n    },\n    Permission: \"edit\",\n    SubjectReference: &v1.RelationReference{\n        Type: \"user\",\n        Relation: \"\",\n    },\n    PageSize: 20,\n    ContinuousToken: \"\",\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.permission.lookupSubject({\n    tenantId: \"t1\",\n    metadata: {\n        snapToken: \"\",\n        schemaVersion: \"\",\n        depth: 20,\n    },\n    entity: {\n        type: \"document\",\n        id: \"1\",\n    },\n    permission: \"edit\",\n    subject_reference: {\n        type: \"user\",\n        relation: \"\"\n    },\n    page_size: 10,\n    continuous_token: \"\"\n}).then((response) => {\n    console.log(response.subject_ids)\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/lookup-subject' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"metadata\":{\n    \"snap_token\": \"\",\n    \"schema_version\": \"\",\n    \"depth\": 20,\n  },\n  \"entity\": {\n    \"type\": \"document\",\n    \"id\": \"1\"\n  },\n  \"permission\": \"edit\",\n  \"subject_reference\": {\n    \"type\": \"user\",\n    \"relation\": \"\"\n  },\n   page_size: 20,\n   continuous_token: \"\"\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/permissions/lookup-subject", body: "*" } }, I: PermissionLookupSubjectRequest, O: PermissionLookupSubjectResponse },
    { name: "SubjectPermission", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Permission"], summary: "subject permission", operationId: "permissions.subjectPermission", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "cr, err := client.Permission.SubjectPermission(context.Background(), &v1.PermissionSubjectPermissionRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.PermissionSubjectPermissionRequestMetadata{\n        SnapToken: \"\",\n        SchemaVersion: \"\",\n        OnlyPermission: false,\n        Depth: 20,\n    },\n    Entity: &v1.Entity{\n        Type: \"repository\",\n        Id: \"1\",\n    },\n    Subject: &v1.Subject{\n        Type: \"user\",\n        Id: \"1\",\n    },\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.permission.subjectPermission({\n    tenantId: \"t1\",\n    metadata: {\n        snapToken: \"\",\n        schemaVersion: \"\",\n        onlyPermission: true,\n        depth: 20\n    },\n    entity: {\n        type: \"repository\",\n        id: \"1\"\n    },\n    subject: {\n        type: \"user\",\n        id: \"1\"\n    }\n}).then((response) => {\n    console.log(response);\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/permissions/subject-permission' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"metadata\":{\n    \"snap_token\": \"\",\n    \"schema_version\": \"\",\n    \"only_permission\": true,\n    \"depth\": 20\n  },\n  \"entity\": {\n    \"type\": \"repository\",\n    \"id\": \"1\"\n  },\n  \"subject\": {\n    \"type\": \"user\",\n    \"id\": \"1\",\n    \"relation\": \"\"\n  }\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/permissions/subject-permission", body: "*" } }, I: PermissionSubjectPermissionRequest, O: PermissionSubjectPermissionResponse }
]);
/**
 * @generated ServiceType for protobuf service base.v1.Watch
 */
export const Watch = new ServiceType("base.v1.Watch", [
    { name: "Watch", serverStreaming: true, options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Watch"], summary: "watch changes", operationId: "watch.watch", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "cr, err := client.Watch.Watch(context.Background(), &v1.WatchRequest{\n    TenantId:  \"t1\",\n    SnapToken: \"\",\n})\n// handle stream response\nfor {\n    res, err := cr.Recv()\n\n    if err == io.EOF {\n        break\n    }\n\n    // res.Changes\n}\n" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "const permify = require(\"@permify/permify-node\");\nconst {WatchResponse} = require(\"@permify/permify-node/dist/src/grpc/generated/base/v1/service\");\n\nfunction main() {\n    const client = new permify.grpc.newClient({\n        endpoint: \"localhost:3478\",\n    });\n\n    let res = client.watch.watch({\n        tenantId: \"t1\",\n        snapToken: \"\"\n    });\n\n    handle(res);\n}\n\nasync function handle(res: AsyncIterable<WatchResponse>) {\n    for await (const response of res) {\n        // response.changes\n    }\n}\n" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/watch", body: "*" } }, I: WatchRequest, O: WatchResponse }
]);
/**
 * @generated ServiceType for protobuf service base.v1.Schema
 */
export const Schema = new ServiceType("base.v1.Schema", [
    { name: "Write", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Schema"], summary: "write schema", operationId: "schemas.write", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "sr, err := client.Schema.Write(context.Background(), &v1.SchemaWriteRequest{\n    TenantId: \"t1\",\n    Schema: `\n    entity user {}\n\n    entity organization {\n        relation admin @user\n        relation member @user\n\n        action create_repository = (admin or member)\n        action delete = admin\n    }\n\n    entity repository {\n        relation owner @user\n        relation parent @organization\n\n        action push = owner\n        action read = (owner and (parent.admin and parent.member))\n        action delete = (parent.member and (parent.admin or owner))\n    }\n    `,\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.schema.write({\n    tenantId: \"t1\",\n    schema: `\n    entity user {}\n\n    entity organization {\n        relation admin @user\n        relation member @user\n\n        action create_repository = (admin or member)\n        action delete = admin\n    }\n\n    entity repository {\n        relation owner @user\n        relation parent @organization\n\n        action push = owner\n        action read = (owner and (parent.admin and parent.member))\n        action delete = (parent.member and (parent.admin or owner))\n    }\n    `\n}).then((response) => {\n    // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/schemas/write' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"schema\": \"entity user {}\\n\\n    entity organization {\\n\\n        relation admin @user\\n        relation member @user\\n\\n        action create_repository = (admin or member)\\n        action delete = admin\\n    }\\n\\n    entity repository {\\n\\n        relation owner @user\\n        relation parent @organization\\n\\n        action push = owner\\n        action read = (owner and (parent.admin and parent.member))\\n        action delete = (parent.member and (parent.admin or owner))\\n }\"\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/schemas/write", body: "*" } }, I: SchemaWriteRequest, O: SchemaWriteResponse },
    { name: "PartialWrite", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Schema"], summary: "partially update your authorization model", operationId: "schemas.partial-write" }, "google.api.http": { patch: "/v1/tenants/{tenant_id}/schemas/partial-write", body: "*" } }, I: SchemaPartialWriteRequest, O: SchemaPartialWriteResponse },
    { name: "Read", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Schema"], summary: "read schema", operationId: "schemas.read", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "sr, err := client.Schema.Read(context.Background(), &v1.SchemaReadRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.SchemaReadRequestMetadata{\n        SchemaVersion: \"cnbe6se5fmal18gpc66g\",\n    },\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "let res = client.schema.read({\n    tenantId: \"t1\",\n    metadata: {\n        schemaVersion: swResponse.schemaVersion,\n    },\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/schemas/read' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"metadata\": {\n        \"schema_version\": \"cnbe6se5fmal18gpc66g\"\n    }\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/schemas/read", body: "*" } }, I: SchemaReadRequest, O: SchemaReadResponse },
    { name: "List", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Schema"], summary: "list schema", operationId: "schemas.list", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "sr, err := client.Schema.List(context.Background(), &v1.SchemaListRequest{\n    TenantId: \"t1\",\n    PageSize: 20,\n    ContinuousToken: \"\",\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "let res = client.schema.list({\n    tenantId: \"t1\",\n    continuousToken: \"\"\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/schemas/list' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"page_size\": 20,\n    \"continuous_token\": \"\"\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/schemas/list", body: "*" } }, I: SchemaListRequest, O: SchemaListResponse }
]);
/**
 * @generated ServiceType for protobuf service base.v1.Data
 */
export const Data = new ServiceType("base.v1.Data", [
    { name: "Write", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Data"], summary: "write data", operationId: "data.write", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "// Convert the wrapped attribute value into Any proto message\nvalue, err := anypb.New(&v1.BooleanValue{\n    Data: true,\n})\nif err != nil {\n    // Handle error\n}\n\ncr, err := client.Data.Write(context.Background(), &v1.DataWriteRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.DataWriteRequestMetadata{\n        SchemaVersion: \"\",\n    },\n    Tuples: []*v1.Tuple{\n        {\n            Entity: &v1.Entity{\n                Type: \"document\",\n                Id:   \"1\",\n            },\n            Relation: \"editor\",\n            Subject:  &v1.Subject{\n                Type: \"user\",\n                Id:   \"1\",\n                Relation: \"\",\n            },\n        },\n    },\n    Attributes: []*v1.Attribute{\n        {\n            Entity: &v1.Entity{\n                Type: \"document\",\n                Id:   \"1\",\n            },\n            Attribute: \"is_private\",\n            Value:     value,\n        },\n    },\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "const booleanValue = BooleanValue.fromJSON({ data: true });\n\nconst value = Any.fromJSON({\n    typeUrl: 'type.googleapis.com/base.v1.BooleanValue',\n    value: BooleanValue.encode(booleanValue).finish()\n});\n\nclient.data.write({\n    tenantId: \"t1\",\n    metadata: {\n        schemaVersion: \"\"\n    },\n    tuples: [{\n        entity: {\n            type: \"document\",\n            id: \"1\"\n        },\n        relation: \"editor\",\n        subject: {\n            type: \"user\",\n            id: \"1\"\n        }\n    }],\n    attributes: [{\n        entity: {\n            type: \"document\",\n            id: \"1\"\n        },\n        attribute: \"is_private\",\n        value: value,\n    }]\n}).then((response) => {\n    // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/write' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"metadata\": {\n        \"schema_version\": \"\"\n    },\n    \"tuples\": [\n        {\n            \"entity\": {\n                \"type\": \"document\",\n                \"id\": \"1\"\n            },\n            \"relation\": \"editor\",\n            \"subject\": {\n                \"type\": \"user\",\n                \"id\": \"1\"\n            }\n        }\n    ],\n    \"attributes\": [\n        {\n            \"entity\": {\n                \"type\": \"document\",\n                \"id\": \"1\"\n            },\n            \"attribute\": \"is_private\",\n            \"value\": {\n                \"@type\": \"type.googleapis.com/base.v1.BooleanValue\",\n                \"data\": true\n            }\n        }\n    ]\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/data/write", body: "*" } }, I: DataWriteRequest, O: DataWriteResponse },
    { name: "WriteRelationships", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Data"], summary: "write relationships", operationId: "relationships.write" }, "google.api.http": { post: "/v1/tenants/{tenant_id}/relationships/write", body: "*" } }, I: RelationshipWriteRequest, O: RelationshipWriteResponse },
    { name: "ReadRelationships", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Data"], summary: "read relationships", operationId: "data.relationships.read", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "rr, err := client.Data.ReadRelationships(context.Background(), &v1.Data.RelationshipReadRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.Data.RelationshipReadRequestMetadata{\n        SnapToken: \"\"\n    },\n    Filter: &v1.TupleFilter{\n        Entity: &v1.EntityFilter{\n            Type: \"organization\",\n            Ids: []string{\"1\"},\n        },\n        Relation: \"member\",\n        Subject: &v1.SubjectFilter{\n            Type: \"\",\n            Id: []string{\"\"},\n            Relation: \"\"\n        }\n    }\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.data.readRelationships({\n  tenantId: \"t1\",\n  metadata: {\n    snap_token: \"\",\n  },\n  filter: {\n    entity: {\n      type: \"organization\",\n      ids: [\n        \"1\"\n      ]\n    },\n    relation: \"member\",\n    subject: {\n      type: \"\",\n      ids: [],\n      relation: \"\"\n    }\n  }\n}).then((response) => {\n  // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/relationships/read' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  metadata: {\n    snap_token: \"\",\n  },\n  filter: {\n    entity: {\n      type: \"organization\",\n      ids: [\n        \"1\"\n      ]\n    },\n    relation: \"member\",\n    subject: {\n      type: \"\",\n      ids: [],\n      relation: \"\"\n    }\n  }\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/data/relationships/read", body: "*" } }, I: RelationshipReadRequest, O: RelationshipReadResponse },
    { name: "ReadAttributes", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Data"], summary: "read attributes", operationId: "data.attributes.read", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "rr, err := client.Data.ReadAttributes(context.Background(), &v1.Data.AttributeReadRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.Data.AttributeReadRequestMetadata{\n        SnapToken: \"\",\n    },\n    Filter: &v1.AttributeFilter{\n        Entity: &v1.EntityFilter{\n            Type: \"organization\",\n            Ids: []string{\"1\"},\n        },\n        Attributes: []string{\"private\"},\n    },\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.data.readAttributes({\n  tenantId: \"t1\",\n  metadata: {\n    snap_token: \"\",\n  },\n  filter: {\n    entity: {\n      type: \"organization\",\n      ids: [\n        \"1\"\n      ]\n    },\n    attributes: [\n      \"private\"\n    ],\n  }\n}).then((response) => {\n  // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/attributes/read' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  metadata: {\n    snap_token: \"\",\n  },\n  filter: {\n    entity: {\n      type: \"organization\",\n      ids: [\n        \"1\"\n      ]\n    },\n    attributes: [\n      \"private\"\n    ],\n  }\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/data/attributes/read", body: "*" } }, I: AttributeReadRequest, O: AttributeReadResponse },
    { name: "Delete", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Data"], summary: "delete data", operationId: "data.delete", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "rr, err := client.Data.Delete(context.Background(), &v1.DataDeleteRequest{\n    TenantId: \"t1\",\n    Metadata: &v1.DataDeleteRequestMetadata{\n        SnapToken: \"\",\n    },\n    TupleFilter: &v1.TupleFilter{\n        Entity: &v1.EntityFilter{\n            Type: \"organization\",\n            Ids: []string{\"1\"},\n        },\n        Relation: \"admin\",\n        Subject: &v1.SubjectFilter{\n            Type: \"user\",\n            Id: []string{\"1\"},\n            Relation: \"\"\n        }\n    }\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.data.delete({\n  tenantId: \"t1\",\n  metadata: {\n    snap_token: \"\",\n  },\n  tupleFilter: {\n    entity: {\n      type: \"organization\",\n      ids: [\n        \"1\"\n      ]\n    },\n    relation: \"admin\",\n    subject: {\n      type: \"user\",\n      ids: [\n        \"1\"\n      ],\n      relation: \"\"\n    }\n  }\n}).then((response) => {\n  // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/delete' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n  \"tuple_filter\": {\n    \"entity\": {\n      \"type\": \"organization\",\n      \"ids\": [\n        \"1\"\n      ]\n    },\n    \"relation\": \"admin\",\n    \"subject\": {\n      \"type\": \"user\",\n      \"ids\": [\n        \"1\"\n      ],\n      \"relation\": \"\"\n    }\n  },\n  \"attribute_filter\": {}\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/data/delete", body: "*" } }, I: DataDeleteRequest, O: DataDeleteResponse },
    { name: "DeleteRelationships", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Data"], summary: "delete relationships", operationId: "relationships.delete" }, "google.api.http": { post: "/v1/tenants/{tenant_id}/relationships/delete", body: "*" } }, I: RelationshipDeleteRequest, O: RelationshipDeleteResponse },
    { name: "RunBundle", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Data"], summary: "run bundle", operationId: "bundle.run", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "rr, err := client.Data.RunBundle(context.Background(), &v1.BundleRunRequest{\n    TenantId: \"t1\",\n    Name:     \"organization_created\",\n    Arguments: map[string]string{\n        \"creatorID\":      \"564\",\n        \"organizationID\": \"789\",\n    },\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.data.runBundle({\n    tenantId: \"t1\",\n    name: \"organization_created\",\n    arguments: {\n        creatorID: \"564\",\n        organizationID: \"789\",\n    }\n}).then((response) => {\n    // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/data/run-bundle' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"name\": \"organization_created\",\n    \"arguments\": {\n        \"creatorID\": \"564\",\n        \"organizationID\": \"789\"\n    }\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/data/run-bundle", body: "*" } }, I: BundleRunRequest, O: BundleRunResponse }
]);
/**
 * @generated ServiceType for protobuf service base.v1.Bundle
 */
export const Bundle = new ServiceType("base.v1.Bundle", [
    { name: "Write", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Bundle"], summary: "write bundle", operationId: "bundle.write", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "rr, err := client.Bundle.Write(context.Background(), &v1.BundleWriteRequest{\n    TenantId: \"t1\",\n    Bundles: []*v1.DataBundle{\n        {\n            Name: \"organization_created\",\n            Arguments: []string{\n                \"creatorID\",\n                \"organizationID\",\n            },\n            Operations: []*v1.Operation{\n                {\n                    RelationshipsWrite: []string{\n                        \"organization:{{.organizationID}}#admin@user:{{.creatorID}}\",\n                        \"organization:{{.organizationID}}#manager@user:{{.creatorID}}\",\n                    },\n                    AttributesWrite: []string{\n                        \"organization:{{.organizationID}}$public|boolean:false\",\n                    },\n                },\n            },\n        },\n    },\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.bundle.write({\n    tenantId: \"t1\",\n    bundles: [\n        {\n            name: \"organization_created\",\n            arguments: [\n                \"creatorID\",\n                \"organizationID\",\n            ],\n            operations: [\n                {\n                    relationships_write: [\n                        \"organization:{{.organizationID}}#admin@user:{{.creatorID}}\",\n                        \"organization:{{.organizationID}}#manager@user:{{.creatorID}}\",\n                    ],\n                    attributes_write: [\n                        \"organization:{{.organizationID}}$public|boolean:false\",\n                    ]\n                }\n            ]\n        }\n    ]\n}).then((response) => {\n    // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/bundle/write' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"bundles\": [\n        {\n            \"name\": \"organization_created\",\n            \"arguments\": [\n                \"creatorID\",\n                \"organizationID\"\n            ],\n            \"operations\": [\n                {\n                    \"relationships_write\": [\n                        \"organization:{{.organizationID}}#admin@user:{{.creatorID}}\",\n                        \"organization:{{.organizationID}}#manager@user:{{.creatorID}}\"\n                    ],\n                    \"attributes_write\": [\n                        \"organization:{{.organizationID}}$public|boolean:false\"\n                    ]\n                }\n            ]\n        }\n    ]\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/bundle/write", body: "*" } }, I: BundleWriteRequest, O: BundleWriteResponse },
    { name: "Read", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Bundle"], summary: "read bundle", operationId: "bundle.read", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "rr, err := client.Bundle.Read(context.Background(), &v1.BundleReadRequest{\n    TenantId: \"t1\",\n    Name:     \"organization_created\",\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.bundle.read({\n    tenantId: \"t1\",\n    name: \"organization_created\",\n}).then((response) => {\n    // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/bundle/read' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"name\": \"organization_created\"\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/bundle/read", body: "*" } }, I: BundleReadRequest, O: BundleReadResponse },
    { name: "Delete", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Bundle"], summary: "delete bundle", operationId: "bundle.delete", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "rr, err := client.Bundle.Delete(context.Background(), &v1.BundleDeleteRequest{\n    TenantId: \"t1\",\n    Name:     \"organization_created\",\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.bundle.delete({\n    tenantId: \"t1\",\n    name: \"organization_created\",\n}).then((response) => {\n    // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/{tenant_id}/bundle/delete' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"name\": \"organization_created\"\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/{tenant_id}/bundle/delete", body: "*" } }, I: BundleDeleteRequest, O: BundleDeleteResponse }
]);
/**
 * @generated ServiceType for protobuf service base.v1.Tenancy
 */
export const Tenancy = new ServiceType("base.v1.Tenancy", [
    { name: "Create", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Tenancy"], summary: "create tenant", operationId: "tenants.create", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "rr, err := client.Tenancy.Create(context.Background(), &v1.TenantCreateRequest{\n    Id:   \"\",\n    Name: \"\"\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.tenancy.create({\n   id: \"\",\n   name: \"\"\n}).then((response) => {\n    // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'http://localhost:3476/v1/tenants/create' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"id\": \"\",\n    \"name\": \"\"\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/create", body: "*" } }, I: TenantCreateRequest, O: TenantCreateResponse },
    { name: "Delete", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Tenancy"], summary: "delete tenant", operationId: "tenants.delete", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "rr, err := client.Tenancy.Delete(context.Background(), &v1.TenantDeleteRequest{\n    Id: \"\"\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "client.tenancy.delete({\n   id: \"\",\n}).then((response) => {\n    // handle response\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request DELETE 'http://localhost:3476/v1/tenants/t1'" } } } }] } } } }, "google.api.http": { delete: "/v1/tenants/{id}" } }, I: TenantDeleteRequest, O: TenantDeleteResponse },
    { name: "List", options: { "grpc.gateway.protoc_gen_openapiv2.options.openapiv2_operation": { tags: ["Tenancy"], summary: "list tenants", operationId: "tenants.list", extensions: { "x-codeSamples": { listValue: { values: [{ structValue: { fields: { label: { stringValue: "go" }, lang: { stringValue: "go" }, source: { stringValue: "cr, err := client.Tenancy.List(context.Background(), &v1.TenantListRequest{\n    PageSize: 20,\n    ContinuousToken: \"\",\n})" } } } }, { structValue: { fields: { label: { stringValue: "node" }, lang: { stringValue: "javascript" }, source: { stringValue: "let res = client.tenancy.list({\n    pageSize: 20,\n    continuousToken: \"\",\n})" } } } }, { structValue: { fields: { label: { stringValue: "cURL" }, lang: { stringValue: "curl" }, source: { stringValue: "curl --location --request POST 'localhost:3476/v1/tenants/list' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"page_size\": 20,\n    \"continuous_token\": \"\"\n}'" } } } }] } } } }, "google.api.http": { post: "/v1/tenants/list", body: "*" } }, I: TenantListRequest, O: TenantListResponse }
]);
